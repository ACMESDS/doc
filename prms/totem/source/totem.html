<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">&quot;use strict&quot;;

var _errors;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// UNCLASSIFIED 

<span id='TOTEM'>/**
</span>@class TOTEM

@requires http
@requires https
@requires fs
@requires constants
@requires clusters
@requires child-process
@requires os
@requires stream
@requires str

@requires enum
@requires jsdb

@requires mime
@requires socket.io
@requires socket.io-clusterhub
@requires mysql
@requires xml2js
@requires toobusy
@requires json2csv
@requires js2xmlparser
@requires toobusy-js
*/

var
// globals
TRACE = &quot;T&gt;&quot;,
    ENV = process.env,


// NodeJS modules
STREAM = require(&quot;stream&quot;),
    // pipe-able streams
HTTP = require(&quot;http&quot;),
    //&lt; http interface
HTTPS = require(&quot;https&quot;),
    //&lt; https interface
CP = require(&quot;child_process&quot;),
    //&lt; spawn OS shell commands
FS = require(&quot;fs&quot;),
    //&lt; access file system
CONS = require(&quot;constants&quot;),
    //&lt; constants for setting tcp sessions
CLUSTER = require(&quot;cluster&quot;),
    //&lt; multicore  processing
URL = require(&quot;url&quot;),
    //&lt; url parsing
NET = require(&quot;net&quot;),
    // network interface
VM = require(&quot;vm&quot;),
    // virtual machines for tasking
OS = require('os'),
    // OS utilitites

// 3rd party modules
MIME = require(&quot;mime&quot;),
    //&lt; file mime types
SIO = require('socket.io'),
    //&lt; Socket.io client mesh
SIOHUB = require('socket.io-clusterhub'),
    //&lt; Socket.io client mesh for multicore app
MYSQL = require(&quot;mysql&quot;),
    //&lt; mysql conector
XML2JS = require(&quot;xml2js&quot;),
    //&lt; xml to json parser (*)
BUSY = require('toobusy-js'),
    //&lt; denial-of-service protector (cant install on NodeJS 5.x+)
JS2XML = require('js2xmlparser'),
    //&lt; JSON to XML parser
JS2CSV = require('json2csv'),
    //&lt; JSON to CSV parser	

// Totem modules
JSDB = require(&quot;jsdb&quot;),
    //&lt; JSDB database agnosticator
sqlThread = JSDB.thread;

var _require = require(&quot;enum&quot;),
    Copy = _require.Copy,
    Each = _require.Each,
    Log = _require.Log,
    isError = _require.isError,
    isArray = _require.isArray,
    isString = _require.isString,
    isFunction = _require.isFunction;

function Trace(msg, sql) {
	TRACE.trace(msg, sql);
}

var TOTEM = module.exports = {

	queues: JSDB.queues, // pass along

	reroute: {//&lt; table -&gt; db.table translators
	},

	init: function init() {},

<span id='TOTEM-cfg-plugins'>	/**
</span> @cfg {Object}
 Plugins for tasker engine context
 */
	plugins: {
		console: console,
		log: console.log
	},

<span id='TOTEM-cfg-onEncrypted'>	/**
</span> @cfg {Boolean}
 @member TOTEM
 Enabled when master/workers on encrypted service
 */
	onEncrypted: {
		true: false, // on master 
		false: false // on worker
	},

	onUpdate: null,

<span id='TOTEM-cfg-tasker'>	/**
</span> @cfg {Function}
 @method tasker
 @member TOTEM
 	Spread one or more tasks to workers residing in a compute node cloud as follows:
 
 	tasker({  		// example
 		keys: &quot;i,j,k&quot;,  	// e.g. array indecies
 		i: [0,1,2,3],  		// domain of index i
 		j: [4,8],				// domain of index j
 		k: [0],					// domain of index k
 		qos: 0,				// regulation time in ms if not zero
 		local: false, 		// enable to run task local, i.e. w/o workers and nodes
 		workers: 4, 		// limit number of workers (aka cores) per node
 		nodes: 3 			// limit number of nodes (ala locales) in the cluster
 	}, 
 		// here, a simple task that returns a message 
 		($) =&gt; &quot;my result is &quot; + (i + j*k) + &quot; from &quot; + $.worker + &quot; on &quot;  + $.node,
 			// here, a simple callback that displays the task results
 		(msg) =&gt; console.log(msg) 
 	);
 
 @param {Object} opts tasking options (see example)
 @param {Function} task tasker of the form ($) =&gt; {return msg} where $ contains process info
 @param {Function} cb callback of the form (msg) =&gt; {...} to process msg returned by task
 */
	tasker: function tasker(opts, task, cb) {

		function genDomain(depth, keys, opts, index, lastIndex, cb) {
			var key = keys[depth],
			    idxs = opts[key] || [],
			    N = idxs.length;

			//Log(depth,key, index, N, lastIndex);
			if (key) idxs.forEach(function (idx, n) {
				index[key] = idx;
				genDomain(depth + 1, keys, opts, index, lastIndex &amp;&amp; n == N - 1, cb);
			});else cb(Copy(index, {}), lastIndex);
		}

		function nodeCB(err) {
			if (err) Log(err);
		}

		var paths = TOTEM.paths,
		    fetcher = TOTEM.fetcher,
		    fetches = 0,
		    node = 0,
		    nodeURL = paths.nodes[node],
		    nodeReq = {
			domain: [],
			client: opts.client || &quot;guest&quot;,
			credit: opts.credit || 10e3,
			name: opts.name || &quot;atask&quot;,
			qos: opts.qos || 0,
			cb: cb + &quot;&quot;
		},
		    dom = nodeReq.domain,
		    keys = opts.keys || &quot;&quot;,
		    cores = opts.cores || opts.workers || 10,
		    shards = opts.shards || 100,
		    nodes = opts.nodes || opts.locales || 50;

		if (opts.local) genDomain(0, keys.split(&quot;,&quot;), opts, {}, true, function (index) {
			cb(task(index));
		});else genDomain(0, keys.split(&quot;,&quot;), opts, {}, true, function (index, isLast) {
			dom.push(index);

			if (isLast || dom.length == shards) {
				if (++fetches &gt; cores) {
					nodeURL = paths.nodes[++node];
					if (!nodeURL) nodeURL = paths.nodes[node = 0];
					fetches = 0;
				}

				if (task) {
					if (isArray(task)) task.forEach(function (task) {
						nodeReq.task = task + &quot;&quot;;
						fetcher(nodeURL, nodeReq, nodeCB);
					});else {
						nodeReq.task = task + &quot;&quot;;
						fetcher(nodeURL, nodeReq, nodeCB);
					}
				} else dom.forEach(cb);

				dom.length = 0;
			}
		});
	},

<span id='TOTEM-cfg-dogs'>	/**
</span> @cfg {Object}
 Watchdogs {name: dog(sql, lims), ... } run every dog.cycle seconds with a dog.trace message using
 specified dog.parms.  When the watchdog is invoked it is given a sql connector and its lims attributes.
 */
	dogs: {//&lt; watchdog functions(sql, lims)
	},

<span id='TOTEM-cfg-watchFile'>	/**
</span> @cfg {Function}
 @private
 @method watchFile
 Establish smart file watcher when file at area/name has changed.
 @param {String} path to file being watched
 @param {Function} callback cb(sql, name, path) when file at path has changed
 */
	watchFile: function watchFile(path, cb) {
		var mTimes = TOTEM.mTimes;

		Trace(&quot;WATCHING &quot; + path);

		mTimes[path] = 0;

		FS.watch(path, function (ev, file) {
			var isSwap = file.charAt(0) == &quot;.&quot;;

			if (file &amp;&amp; !isSwap) switch (ev) {
				case &quot;change&quot;:
					sqlThread(function (sql) {
						Trace(ev.toUpperCase() + &quot; &quot; + file, sql);

						FS.stat(path, function (err, stats) {

							//Log(path, err, stats);
							if (!err &amp;&amp; mTimes[path] != stats.mtime) {
								mTimes[path] = stats.mtime;
								cb(sql, file, path);
							}
						});
					});

					break;

				case &quot;delete&quot;:
				case &quot;rename&quot;:
				default:

			}
		});
	},

<span id='TOTEM-cfg-createCert'>	/**
</span> @cfg {Function}
 @private
 @method createCert
 Create a PKI cert given user name and password.
 @param {String} path to file being watched
 @param {Function} callback cb(sql, name, path) when file at path has changed
 */
	createCert: createCert, //&lt; method to create PKI certificate

<span id='TOTEM-cfg-nodeDivider'>	/**
</span> @cfg {String}
 @member TOTEM
 Node divider NODE $$ NODE ....  (&quot;&quot; disables dividing).
 */
	nodeDivider: &quot;??&quot;, //&lt; node divider

<span id='TOTEM-cfg-maxIndex'>	/**
</span> @cfg {Number}
 @member TOTEM
 Max files to index by the indexFile() method (0 disables).
 */
	maxIndex: 1000, //&lt; max files to index

<span id='TOTEM-cfg-emitter'>	/**
</span> @cfg {Function}
 @private
 @method emitter
 Communicate with socket.io clients
 */
	emitter: null,

<span id='TOTEM-cfg-IO'>	/**
</span> @cfg {Object}
 @private
 @member TOTEM
 Reserved for socket.io support to multiple clients
 */
	IO: null,

<span id='TOTEM-cfg-dsAttrs'>	/**
</span> @cfg {Object}
 @member TOTEM
 Reserved for dataset attributes derived by JSDB.config
 */
	dsAttrs: {},

<span id='TOTEM-cfg-config'>	/**
</span> @cfg {Function}
 @member TOTEM
 @method config
 Configure and start the service with options and optional callback when started.
 @param {Object} opts configuration options following ENUM.Copy() conventions
 @param {Function} cb callback(err) when service started
 */
	config: configService,

<span id='TOTEM-cfg-stop'>	/**
</span> @cfg {Function}
 @member TOTEM	
 @method stop
 Stop the server.
 */
	stop: stopService,

<span id='TOTEM-cfg-thread'>	/**
</span> @cfg {Function}
 @member TOTEM	
 @method thread
 Thread a new sql connection to a callback.  Unless overridden, will default to the JSDB thread method.
 @param {Function} cb callback(sql connector)
  * */
	thread: sqlThread,

<span id='TOTEM-cfg-crud'>	/**
</span> @cfg {Object}  
 @member TOTEM
 REST-to-CRUD translations
 */
	crud: {
		GET: &quot;select&quot;,
		DELETE: &quot;delete&quot;,
		POST: &quot;insert&quot;,
		PUT: &quot;update&quot;
	},

<span id='TOTEM-cfg-reqFlags'>	/**
</span> @cfg {Object} 
 @member TOTEM
 Options to parse request flags
 */
	reqFlags: { //&lt; Properties for request flags
		traps: { //&lt; cb(query) traps to reorganize query
			filters: function filters(req) {
				var flags = req.flags,
				    query = req.query,
				    filters = flags.filters || [];

				filters.forEach(function (filter) {
					return query[filter.property] = filter.value;
				});
			}
		},
		strips: //&lt; Flags to strips from request
		{ &quot;&quot;: 1, &quot;_&quot;: 1, leaf: 1, _dc: 1 },

		//ops: &quot;&lt;&gt;!*$|%/^~&quot;,
		id: &quot;ID&quot;, //&lt; SQL record id
		prefix: &quot;_&quot;, //&lt; Prefix that indicates a field is a flag
		trace: &quot;_trace&quot;, //&lt; Echo flags before and after parse	
		blog: function blog(recs, req, res) {
			//&lt; Default blogger
			res(recs);
		},
		encap: function encap(recs, req, res) {
			//&lt; dataset.encap to encap records
			var rtn = {};
			rtn[req.flags.encap] = recs;
			res(rtn);
		}
	},

<span id='TOTEM-cfg-mysql'>	/**
</span> @cfg {Object} 
 @member TOTEM
 MySQL connection options {host, user, pass, sessions} or nul l to disable
 */
	mysql: { //&lt; null to disable database
		host: ENV.MYSQL_HOST || &quot;localhost&quot;,
		user: ENV.MYSQL_USER || &quot;nobody&quot;,
		pass: ENV.MYSQL_PASS || &quot;secret&quot;,
		sessions: 1000
	},

<span id='TOTEM-cfg-sockets'>	/**
</span> @cfg {Boolean} [sockets=false]
 @member TOTEM
 Enabled to support web sockets
 */
	sockets: false, //&lt; enabled to support web sockets

<span id='TOTEM-cfg-cores'>	/**
</span> @cfg {Number} [cores=0]
 @member TOTEM	
 Number of worker cores (0 for master-only).  If cores&gt;0, masterport should != workPort, master becomes HTTP server, and workers
 become HTTP/HTTPS depending on encrypt option.  In the coreless configuration, master become HTTP/HTTPS depending on 
 encrypt option, and there are no workers.  In this way, a client can access stateless workers on the workerport, and stateful 
 workers via the masterport.	
 */
	cores: 0, //&lt; Number of worker cores (0 for master-only)

<span id='TOTEM-cfg-onFile'>	/**
</span> @cfg {Object}
 @member TOTEM	
 Folder watching callbacks cb(path) 
 */
	onFile: {//&lt; File folder watchers with callbacks cb(path) 
	},

<span id='TOTEM-cfg-mTimes'>	/**
</span> @cfg {Object}
 @member TOTEM	
 File mod-times tracked as OS will trigger multiple events when file changed
 */
	mTimes: {//&lt; File mod-times tracked as OS will trigger multiple events when file changed
	},

<span id='TOTEM-cfg-behindProxy'>	/**
</span> @cfg {Boolean} [behindProxy=false]
 @member TOTEM	
 Enable if https server being proxied
 */
	behindProxy: false, //&lt; Enable if https server being proxied

<span id='TOTEM-cfg-name'>	/**
</span> @cfg {String} [name=&quot;Totem&quot;]
 @member TOTEM	
 Name of this service used to
 	1) derive site parms from mysql openv.apps by Nick=name
 	2) set mysql name.table for guest clients,
 	3) identify server cert name.pfx file.
 If the Nick=name is not located in openv.apps, the supplied	config() options are not overridden.
 */
	host: {
		name: ENV.SERVICE_NAME || &quot;Totem1&quot;,
		encrypt: ENV.SERVICE_PASS || &quot;&quot;,
		worker: ENV.SERVICE_WORKER_URL || &quot;https://localhost:8443&quot;,
		master: ENV.SERVICE_MASTER_URL || &quot;http://localhost:8080&quot;
	},

<span id='TOTEM-cfg-site'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 Site context extended by the mysql derived query when service starts
 */
	site: {//&lt; reserved for derived context vars		
	},

<span id='TOTEM-cfg-reqTypes'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 Endpoint reqTypes cb(ack data as string || error)
 */
	reqTypes: { //&lt; record data convertors
		db: function db(ack, req, res) {
			req.sql.query(&quot;select found_rows()&quot;).on('result', function (stat) {
				// records sourced from sql				
				res({
					success: true,
					msg: &quot;ok&quot;,
					count: stat[&quot;found_rows()&quot;] || 0,
					data: ack
				});
			}).on(&quot;error&quot;, function () {
				// records sourced from virtual table
				res({
					success: true,
					msg: &quot;ok&quot;,
					count: ack.length,
					data: ack
				});
			});
		},

		csv: function csv(ack, req, res) {
			JS2CSV({
				data: ack,
				fields: Object.keys(ack[0] || {})
			}, function (err, csv) {
				res(err || csv);
			});
		},

		&quot;&quot;: function _(ack, req, res) {
			res(ack);
		},

		json: function json(ack, req, res) {
			res(ack);
		},

		xml: function xml(ack, req, res) {
			res(JS2XML.parse(req.table, {
				count: ack.length,
				data: ack
			}));
		}
	},

<span id='TOTEM-cfg-byTable'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 By-table endpoint routers {table: method(req,res), ... } for data fetchers, system and user management
 */
	byTable: { //&lt; by-table routers	
		riddle: sysValidate,
		task: sysTask,
		ping: sysPing
	},

<span id='TOTEM-cfg-byAction'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 By-action endpoint routers for accessing engines
 */
	byAction: {//&lt; by-action routers
	},

<span id='TOTEM-cfg-byType'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 By-type endpoint routers  {type: method(req,res), ... } for accessing dataset readers
 */
	byType: {//&lt; by-type routers
	},

<span id='TOTEM-cfg-byArea'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 By-area endpoint routers {area: method(req,res), ... } for sending/cacheing files
 */
	byArea: { //&lt; by-area routers
		stores: sysArea,
		uploads: sysArea,
		shares: sysArea
	},

<span id='TOTEM-cfg-byActionTable'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 By-action-table endpoint routers {action: {table: method(req,res), ...}, ... } for accessing virtual tables
 */
	byActionTable: { //&lt; by-action-table routers
		select: {
			//user: selectUser
		},
		delete: {
			//user: deleteUser
		},
		update: {
			//user: updateUser
		},
		insert: {
			//user: insertUser
		},
		execute: {
			//user: executeUser
		}
	},

<span id='TOTEM-cfg-trustStore'>	/**
</span> @cfg {Object} 
 @private
 @member TOTEM	
 Trust store extened with certs in the certs.truststore folder when the service starts in encrypted mode
 */
	trustStore: [], //&lt; reserved for trust store

<span id='TOTEM-cfg-server'>	/**
</span> @cfg {Object} 
 @private
 @member TOTEM	
 CRUDE (req,res) method to respond to Totem request
 */
	server: null, //&lt; established by TOTEM at config

	//====================================== CRUDE interface

<span id='TOTEM-cfg-selectDS'>	/**
</span> @cfg {Function}
 @method selectDS
 @member TOTEM	
 CRUDE (req,res) method to respond to a select||GET request
 @param {Object} req Totem session request
 @param {Function} res Totem responder
 */
	select: selectDS,
<span id='TOTEM-cfg-update'>	/**
</span> @cfg {Function}	
 @method update
 @member TOTEM	
 CRUDE (req,res) method to respond to a update||POST request
 @param {Object} req Totem session request
 @param {Function} res Totem responder
 */
	update: updateDS,
<span id='TOTEM-cfg-delete'>	/**
</span> @cfg {Function}	
 @method delete
 @member TOTEM	
 CRUDE (req,res) method to respond to a delete||DELETE request
 @param {Object} req Totem session request
 @param {Function} res Totem responder
 */
	delete: deleteDS,
<span id='TOTEM-cfg-insert'>	/**
</span> @cfg {Function}
 @method insert
 @member TOTEM	
 CRUDE (req,res) method to respond to a insert||PUT request
 @param {Object} req Totem session request
 @param {Function} res Totem responder
 */
	insert: insertDS,
<span id='TOTEM-cfg-execute'>	/**
</span> @cfg {Function}
 @method execute
 @member TOTEM	
 CRUDE (req,res) method to respond to a Totem request
 @param {Object} req Totem session request
 @param {Function} res Totem responder
 */
	execute: executeDS,

	//====================================== MISC

<span id='TOTEM-cfg-started'>	/**
</span> @cfg {Date} 
 @private
 @member TOTEM	
 totem start time
 */
	started: null, //&lt; totem start time

<span id='TOTEM-cfg-fetcher'>	/**
</span> @cfg {Function} 
 @private
 @member TOTEM	
 Fetches data from this/other service and forward returned information (as a string, &quot;&quot; if an error occured) to the provided callback.
 @param {String} path &quot;http || https || curl || curls || wget || wgets || / &quot;-prefixed url
 @param {Object} post POST parameters or null
 @param {Function} cb callback(string results)
  */
	fetcher: Copy({
<span id='TOTEM-cfg-retries'>		/**
</span>  @cfg {Number} [retries=5]
  @member TOTEM	
  Maximum number of retries the data fetcher will user
  */
		retries: 5, //&lt; Maximum number of retries the data fetcher will user

<span id='TOTEM-cfg-trace'>		/**
</span>  @cfg {Boolean} [trace=true]
  @member TOTEM	
  Enable/disable tracing of data fetchers
  */
		trace: true //&lt; Enable/disable tracing of data fetchers		
	}, function fetcher(path, post, cb) {
		//&lt; data fetching

		function retry(cmd, cb) {
			// wget-curl retry logic

			function trycmd(retries, cmd, cb) {

				if (trace) Trace(&quot;TRY[&quot; + opts.retry + &quot;] &quot; + cmd);

				CP.exec(cmd, function (err, stdout, stderr) {
					if (err) {
						if (retries) trycmd(--retries, cmd, cb);else cb(TOTEM.errors.retry);
					} else if (cb) cb(null, stdout);
				});
			}

			if (retries) trycmd(retries, cmd, cb);else CP.exec(cmd, function (err, stdout, stderr) {
				cb(err, stdout);
			});
		}

		function getResponse(Res) {
			var body = &quot;&quot;;
			Res.on(&quot;data&quot;, function (chunk) {
				body += chunk.toString();
			});

			Res.on(&quot;end&quot;, function () {
				cb(body);
			});
		}

		var url = path.charAt(0) == &quot;/&quot; ? TOTEM.host.master + path : path,
		    opts = URL.parse(url),
		    protocol = opts.protocol || &quot;&quot;,
		    trace = this.trace,
		    retries = this.retries,
		    cert = TOTEM.cache.certs.fetch;

		opts.rejectUnauthorized = false;
		opts.agent = false;
		opts.method = post ? &quot;PUT&quot; : &quot;GET&quot;;
		opts.port = opts.port || (protocol.endsWith(&quot;s:&quot;) ? 443 : 80);
		// opts.cipher = &quot; ... &quot;
		// opts.headers = { ... }
		// opts.Cookie = [&quot;x=y&quot;, ...]
		/*if (opts.soap) {
  	opts.headers = {
  		&quot;Content-Type&quot;: &quot;application/soap+xml; charset=utf8&quot;,
  		&quot;Content-Length&quot;: opts.soap.length
  	};
  	opts.method = &quot;POST&quot;;
  }*/

		//Log(opts,url);
		Trace(&quot;FETCH &quot; + url);

		switch (protocol) {
			case &quot;curl:&quot;:
				retry(&quot;curl &quot; + url.replace(protocol, &quot;http:&quot;), function (err, out) {
					cb(err ? &quot;&quot; : out);
				});
				break;

			case &quot;curls&quot;:
				retry(&quot;curl -gk --cert &quot; + cert._crt + &quot;:&quot; + cert._pass + &quot; --key &quot; + cert._key + &quot; --cacert &quot; + cert._ca + url.replace(protocol, &quot;https:&quot;), function (err, out) {
					cb(err ? &quot;&quot; : out);
				});
				break;

			case &quot;wget:&quot;:
				var parts = url.split(&quot; &gt;&gt; &quot;),
				    url = parts[0],
				    out = parts[1] || &quot;./temps/wget.jpg&quot;;

				retry(&quot;wget -O &quot; + out + &quot; &quot; + url.replace(protocol, &quot;http:&quot;), function (err) {
					cb(err ? &quot;&quot; : &quot;ok&quot;);
				});
				break;

			case &quot;wgets:&quot;:
				var parts = url.split(&quot; &gt;&gt; &quot;),
				    url = parts[0],
				    out = parts[1] || &quot;./temps/wget.jpg&quot;;

				retry(&quot;wget -O &quot; + out + &quot; --no-check-certificate --certificate &quot; + cert._crt + &quot; --private-key &quot; + cert._key + &quot; &quot; + url.replace(protocol, &quot;https:&quot;), function (err) {
					cb(err ? &quot;&quot; : &quot;ok&quot;);
				});
				break;

			case &quot;http:&quot;:
				try {
					var Req = HTTP.request(opts, getResponse);
				} catch (err) {
					cb(&quot;&quot;);
				}

				Req.on('error', function (err) {
					Log(&quot;FETCH FAIL&quot;, err);
					cb(&quot;&quot;);
				});

				if (post) Req.write(JSON.stringify(post)); // post parms

				Req.end();
				break;

			case &quot;https:&quot;:
				opts.pfx = cert.pfx;
				opts.passphrase = cert._pass;

				try {
					var Req = HTTPS.request(opts, getResponse);
				} catch (err) {
					return cb(&quot;&quot;);
				}

				Req.on('error', function (err) {
					Log(&quot;FETCH FAIL&quot;, err);
					cb(&quot;&quot;);
				});

				if (body) Req.write(JSON.stringify(body)); // body parms

				Req.end();
				break;

			default:
				cb(&quot;&quot;);
		}
	}),

<span id='TOTEM-cfg-faultless'>	/**
</span> @cfg {Boolean} 
 @member TOTEM	
 Enable/disable service fault protection guards
 */
	faultless: false, //&lt; enable to use all defined guards

<span id='TOTEM-cfg-guards'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 Service guard modes
 */
	guards: {// faults to trap 
		//SIGUSR1:1,
		//SIGTERM:1,
		//SIGINT:1,
		//SIGPIPE:1,
		//SIGHUP:1,
		//SIGBREAK:1,
		//SIGWINCH:1,
		//SIGKILL:1,
		//SIGSTOP:1 
	},

<span id='TOTEM-cfg-admitRules'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 Client admission rules
 */
	admitRules: {// empty or null to disable rules
		// CN: &quot;james brian d jamesbd&quot;,
		// O: &quot;u.s. governement&quot;,
		// OU: [&quot;nga&quot;, &quot;dod&quot;],
		// C: &quot;us&quot;
	},

	admitClient: function admitClient(req, profile, cb) {
<span id='TOTEM-cfg-admit'>		/**
</span>  @cfg {Object} 
  @member TOTEM
  Attaches the profile, group and a session metric log to this req request (cert,sql) with 
  callback cb(error) where error reflects testing of client cert and profile credentials.
  */
		function admit(cb) {
			// callback cb(log || null) with session log 
			cb({
				Event: now, // start time
				Action: req.action, // db action
				Stamp: TOTEM.host.name // site name
			});
		}

		var cert = req.cert,
		    sql = req.sql,
		    now = new Date(),
		    errors = TOTEM.errors,
		    rules = TOTEM.admitRules;

		if (cert) {
			if (now &lt; new Date(cert.valid_from) || now &gt; new Date(cert.valid_to)) cb(errors.expiredCert);else if (user = cert.subject || cert.issuer) {
				for (var key in rules) {
					if (test = user[key]) {
						if (test.toLowerCase().indexOf(rule[key]) &lt; 0) return cb(errors.rejectedClient);
					} else return cb(errors.rejectedClient);
				}if (msg = profile.Banned) // block client if banned
					cb(new Error(msg));else admit(function (log) {
					req.log = log ? new Object(log) : null;
					req.profile = new Object(profile);
					req.group = profile.Group;
					cb(null);
				});
			} else cb(errors.rejectedClient);
		} else if (req.encrypted) cb(errors.rejectedClient);else admit(function (log) {
			req.log = log ? new Object(log) : null;
			req.profile = new Object(profile);
			req.group = profile.Group;
			cb(null);
		});
	},

<span id='TOTEM-cfg-guestProfile'>	/**
</span> @cfg {Object}
 @member TOTEM	
 Default guest profile (unencrypted or client profile not found).  Null to bar guests.
 */
	guestProfile: { //&lt; null if guests are barred
		Banned: &quot;&quot;, // nonempty to ban user
		QoS: 10, // [secs] job regulation interval
		Credit: 100, // job cred its
		Charge: 0, // current job charges
		LikeUs: 0, // number of user likeus
		Challenge: 1, // enable to challenge user at session join
		Client: &quot;guest@guest.org&quot;, // default client id
		User: &quot;guest&quot;, // default user ID (reserved for login)
		Group: &quot;app&quot;, // default group name (db to access)
		IDs: &quot;{}&quot;, // challenge key:value pairs
		Repoll: true, // challenge repoll during active sessions
		Retries: 5, // challenge number of retrys before session killed
		Timeout: 30, // challenge timeout in secs
		Message: &quot;Welcome guest - what is (riddle)?&quot; // challenge message with riddles, ids, etc
	},

<span id='TOTEM-cfg-riddles'>	/**
</span> @cfg {Number} [riddles=0]
 @member TOTEM	
 Number of riddles to protect site (0 to disable anti-bot)
 */
	riddles: 0,

<span id='TOTEM-cfg-riddle'>	/**
</span> @cfg {Array} 
 @private
 @member TOTEM	
 Store generated riddles to protect site 
 */
	riddle: [], //&lt; reserved for riddles

<span id='TOTEM-cfg-riddleMap'>	/**
</span> @cfg {Object} 
 @private
 @member TOTEM	
 Riddle digit-to-jpeg map (null to disable riddles)
 */
	riddleMap: {
		0: [&quot;10&quot;, &quot;210&quot;],
		1: [&quot;30&quot;, &quot;60&quot;],
		2: [&quot;50&quot;, &quot;160&quot;],
		3: [&quot;70&quot;, &quot;100&quot;],
		4: [&quot;20&quot;, &quot;90&quot;],
		5: [&quot;00&quot;, &quot;110&quot;],
		6: [&quot;130&quot;, &quot;180&quot;],
		7: [&quot;150&quot;, &quot;290&quot;],
		8: [&quot;170&quot;, &quot;310&quot;],
		9: [&quot;40&quot;, &quot;190&quot;]
	},

<span id='TOTEM-cfg-paths'>	/**
</span> @cfg {Object} 
 @private
 @member TOTEM	
 Default paths to service files
 */
	paths: {
		nourl: &quot;/ping&quot;,

		url: {
			//fetch: &quot;http://localhost:8081?return=${req.query.file}&amp;opt=${plugin.ex1(req)+plugin.ex2}&quot;,
			//default: &quot;/home&quot;,
			//resetpass: &quot;/resetpass&quot;,
			wget: &quot;http://localhost:8081?return=${req.query.file}&amp;opt=${plugin.ex1(req)+plugin.ex2}&quot;,
			curl: &quot;http://localhost:8081?return=${req.query.file}&amp;opt=${plugin.ex1(req)+plugin.ex2}&quot;,
			http: &quot;http://localhost:8081?return=${req.query.file}&amp;opt=${plugin.ex1(req)+plugin.ex2}&quot;,
			socketio: &quot;/socket.io/socket.io.js&quot;,
			riddler: &quot;/riddle&quot;
		},

		certs: &quot;./certs/&quot;,

		mysql: {
			//logThreads: &quot;show session status like 'Thread%'&quot;,
			users: &quot;SELECT 'user' AS Role, group_concat(DISTINCT dataset SEPARATOR ';') AS Contact FROM app.dblogs WHERE instr(dataset,'@')&quot;,
			derive: &quot;SELECT * FROM openv.apps WHERE ? LIMIT 1&quot;,
			//logMetrics: &quot;INSERT INTO app.dblogs SET ? ON DUPLICATE KEY UPDATE Actions=Actions+1, Transfer=Transfer+?, Delay=Delay+?, Event=?&quot;,
			search: &quot;SELECT * FROM app.files HAVING Score &gt; 0.1&quot;,
			//credit: &quot;SELECT * FROM app.files LEFT JOIN openv.profiles ON openv.profiles.Client = files.Client WHERE least(?) LIMIT 1&quot;,
			getProfile: &quot;SELECT * FROM openv.profiles WHERE ? LIMIT 1&quot;,
			newProfile: &quot;INSERT INTO openv.profiles SET ?&quot;,
			getSession: &quot;SELECT * FROM openv.sessions WHERE ? LIMIT 1&quot;,
			newSession: &quot;INSERT INTO openv.sessions SET ? ON DUPLICATE KEY UPDATE Connects=Connects+1&quot;,
			challenge: &quot;SELECT * FROM openv.profiles WHERE least(?,1) LIMIT 1&quot;,
			guest: &quot;SELECT * FROM openv.profiles WHERE Client='guest@guest.org' LIMIT 1&quot;,
			pocs: &quot;SELECT lower(Hawk) AS Role, group_concat(DISTINCT Client SEPARATOR ';') AS Contact FROM openv.roles GROUP BY hawk&quot;
		},

		nodes: { // available nodes for task sharding
			0: ENV.SHARD0 || &quot;http://localhost:8080/task&quot;,
			1: ENV.SHARD1 || &quot;http://localhost:8080/task&quot;,
			2: ENV.SHARD2 || &quot;http://localhost:8080/task&quot;,
			3: ENV.SHARD3 || &quot;http://localhost:8080/task&quot;
		},

		mime: { // default static file areas
			files: &quot;.&quot;, // path to shared files 
			&quot;socket.io&quot;: &quot;.&quot;, // path to socket.io
			captcha: &quot;.&quot;, // path to antibot captchas
			index: { //&lt; paths for allowed file indexers (&quot;&quot; to use url path)
				files: &quot;&quot;
			},
			extensions: {// extend mime types as needed
			}
		}
	},

<span id='TOTEM-cfg-errors'>	/**
</span> @cfg {Object} 
 @private
 @member TOTEM	
 Error messages
 */
	errors: (_errors = {
		pretty: function pretty(err) {
			return err + &quot;&quot;;
		},
		noID: new Error(&quot;missing record ID&quot;),
		badMethod: new Error(&quot;unsupported request method&quot;),
		noProtocol: new Error(&quot;no protocol specified to fetch&quot;),
		noRoute: new Error(&quot;no route&quot;),
		badQuery: new Error(&quot;invalid query&quot;),
		badGroup: new Error(&quot;invalid group requested&quot;),
		lostConnection: new Error(&quot;client connection lost&quot;),
		noDB: new Error(&quot;database unavailable&quot;),
		noProfile: new Error(&quot;user profile could not be determined&quot;),
		failedUser: new Error(&quot;failed modification of user profile&quot;),
		missingPass: new Error(&quot;missing initial user password&quot;),
		expiredCert: new Error(&quot;cert expired&quot;),
		rejectedClient: new Error(&quot;client rejected - bad cert, profile or session&quot;),
		tooBusy: new Error(&quot;too busy - try again later&quot;),
		noFile: new Error(&quot;file not found&quot;),
		noIndex: new Error(&quot;cannot index files here&quot;),
		badType: new Error(&quot;no such dataset type&quot;),
		badReturn: new Error(&quot;nothing returned&quot;),
		noSockets: new Error(&quot;socket.io failed&quot;),
		noService: new Error(&quot;no service  to start&quot;),
		noData: new Error(&quot;no data returned&quot;),
		retry: new Error(&quot;data fetch retries exceeded&quot;),
		notAllowed: new Error(&quot;this endpoint is disabled&quot;)
	}, _defineProperty(_errors, &quot;noID&quot;, new Error(&quot;missing session id&quot;)), _defineProperty(_errors, &quot;noSession&quot;, new Error(&quot;no such session started&quot;)), _defineProperty(_errors, &quot;noAccess&quot;, new Error(&quot;no access to master core at this endpoint&quot;)), _errors),

<span id='TOTEM-cfg-indexFile'>	/**
</span> @method 
 @cfg {Function}
 @member TOTEM	
 	File indexer
 */
	indexFile: indexFile,

<span id='TOTEM-cfg-getFile'>	/**
</span> @method 
 @cfg {Function}
 @member TOTEM	
 	Get a file and make it if it does not exist
 */
	getFile: getFile,

<span id='TOTEM-cfg-uploadFile'>	/**
</span> @cfg {Function}
 @method uploadFile
 @member TOTEM	
 File uploader 
 */
	uploadFile: uploadFile,

<span id='TOTEM-cfg-busycycle'>	/**
</span> @cfg {Number}
 @member TOTEM	
 Server toobusy check period in seconds
 */
	busycycle: 5000, //&lt; site too-busy check interval [ms] (0 disables)

<span id='TOTEM-cfg-setContext'>	/**
</span> @cfg {Function}
 @private
 @member TOTEM	
 Sets the site context parameters available in TOTEM.site.
 */
	setContext: function setContext(sql, cb) {
		var site = TOTEM.site,
		    paths = TOTEM.paths,
		    mysql = paths.mysql;

		site.pocs = {};
		site.distro = {};

		if (pocs = mysql.pocs) sql.query(pocs).on(&quot;result&quot;, function (poc) {
			site.pocs[poc.Role] = poc.Contact;
			site.distro[poc.Role] = poc.Role.link(&quot;mailto:&quot; + poc.Contact);
		});

		if (users = mysql.users) sql.query(users).on(&quot;result&quot;, function (poc) {
			site.pocs[poc.Role] = poc.Contact;
			site.distro[poc.Role] = poc.Role.link(&quot;mailto:&quot; + poc.Contact);
		});

		if (guest = mysql.guest) sql.query(guest).on(&quot;result&quot;, function (rec) {
			TOTEM.guestProfile = Copy(rec, {});
			delete TOTEM.guestProfile.ID;
		});

		if (derive = mysql.derive) // derive site context vars
			sql.query(derive, { Nick: TOTEM.host.name }).on(&quot;result&quot;, function (opts) {
				Each(opts, function (key, val) {
					key = key.toLowerCase();
					site[key] = val;

					if (isString(val || 0)) try {
						site[key] = JSON.parse(val);
					} catch (err) {}

					if (key in TOTEM) TOTEM[key] = site[key];
				});

				if (cb) cb();
			});

		sql.query(&quot;SELECT count(ID) AS Fails FROM openv.aspreqts WHERE Status LIKE '%fail%'&quot;, [], function (err, asp) {
			sql.query(&quot;SELECT count(ID) AS Fails FROM openv.ispreqts WHERE Status LIKE '%fail%'&quot;, [], function (err, isp) {
				sql.query(&quot;SELECT count(ID) AS Fails FROM openv.swreqts WHERE Status LIKE '%fail%'&quot;, [], function (err, sw) {
					sql.query(&quot;SELECT count(ID) AS Fails FROM openv.hwreqts WHERE Status LIKE '%fail%'&quot;, [], function (err, hw) {

						site.warning = [site.warning || &quot;&quot;, &quot;ASP&quot;.fontcolor(asp[0].Fails ? &quot;red&quot; : &quot;green&quot;).tag(&quot;a&quot;, { href: &quot;/help?from=asp&quot; }), &quot;ISP&quot;.fontcolor(isp[0].Fails ? &quot;red&quot; : &quot;green&quot;).tag(&quot;a&quot;, { href: &quot;/help?from=isp&quot; }), &quot;SW&quot;.fontcolor(sw[0].Fails ? &quot;red&quot; : &quot;green&quot;).tag(&quot;a&quot;, { href: &quot;/help?from=swap&quot; }), // mails list of failed swapIDs (and link to all sw reqts) to swap PMO
						&quot;HW&quot;.fontcolor(hw[0].Fails ? &quot;red&quot; : &quot;green&quot;).tag(&quot;a&quot;, { href: &quot;/help?from=pmo&quot; }) // mails list of failed hw reqts (and link to all hw reqts) to pod lead
						].join(&quot; &quot;);
					});
				});
			});
		});
	},

<span id='TOTEM-cfg-cache'>	/**
</span> @cfg {Object} 
 @member TOTEM	
 @private
 File cache
 */
	cache: { //&lt; cacheing options

		never: { //&lt; files to never cache - useful while debugging client side stuff
			&quot;base.js&quot;: 1,
			&quot;extjs.js&quot;: 1,
			&quot;jquery.js&quot;: 1,
			&quot;flow.js&quot;: 1,
			&quot;dojo.js&quot;: 1,
			&quot;games.js&quot;: 1,
			&quot;capture.js&quot;: 1,
			&quot;jade&quot;: 1,
			&quot;view&quot;: 1,
			&quot;gif&quot;: 1
		},

		clients: { // byType cache of clients area
			js: {},
			css: {},
			ico: {}
		},

		&quot;socket.io&quot;: { // byType cache of socketio area
			js: {}
		},

		learnedTables: true,

		certs: {} // reserved for client crts (pfx, crt, and key reserved for server)
	}

};

<span id='TOTEM-End_Points-CRUD_Interface'>/**
</span> * @class TOTEM.End_Points.CRUD_Interface
 * Create / insert / post, Read / select / get, Update / put, Delete methods.
 */

function selectDS(req, res) {
<span id='TOTEM-End_Points-CRUD_Interface-method-selectDS'>	/**
</span> @private
 @method selectDS
 @param {Object} req Totem's request
 @param {Function} res Totem's response callback
 */
	var sql = req.sql,
	    // sql connection
	flags = req.flags,
	    where = req.where,
	    index = flags.index || req.index;

	sql.runQuery({
		crud: req.action,
		from: req.table,
		db: req.group || &quot;app&quot;,
		where: where,
		index: index,
		having: {},
		client: req.client
	}, null, function (err, recs) {

		res(err || recs);
	});
}

function insertDS(req, res) {
<span id='TOTEM-End_Points-CRUD_Interface-method-insertDS'>	/**
</span> @private
 @method insertDS
 @param {Object} req Totem's request
 @param {Function} res Totem's response callback
 */
	var sql = req.sql,
	    // sql connection
	flags = req.flags,
	    body = req.body;

	sql.runQuery({
		crud: req.action,
		from: req.table,
		db: req.group || &quot;app&quot;,
		set: body,
		client: req.client
	}, TOTEM.emitter, function (err, info) {

		//Log(info);
		res(err || info);
	});
}

function deleteDS(req, res) {
<span id='TOTEM-End_Points-CRUD_Interface-method-deleteDS'>	/**
</span> @private
 @method deleteDS
 @param {Object} req Totem's request
 @param {Function} res Totem's response callback
 */
	var sql = req.sql,
	    // sql connection
	flags = req.flags,
	    where = req.where;

	if (where.ID) sql.runQuery({
		crud: req.action,
		from: req.table,
		db: req.group || &quot;app&quot;,
		where: where,
		client: req.client
	}, TOTEM.emitter, function (err, info) {

		//Log(info);
		res(err || info);
	});else res(TOTEM.errors.noID);
}

function updateDS(req, res) {
<span id='TOTEM-End_Points-CRUD_Interface-method-updateDS'>	/**
</span> @private
 @method updateDS
 @param {Object} req Totem's request
 @param {Function} res Totem's response callback
 */
	var sql = req.sql,
	    // sql connection
	flags = req.flags,
	    body = req.body,
	    ds = req.table,
	    where = req.where;

	//Log(req.action, query, body);

	if (isEmpty(body)) res(TOTEM.errors.noBody);else if (where.ID) sql.runQuery({
		crud: req.action,
		from: req.table,
		db: req.group || &quot;app&quot;,
		where: where,
		set: body,
		client: req.client
	}, TOTEM.emitter, function (err, info) {

		//Log(info);
		res(err || info);

		if (onUpdate = TOTEM.onUpdate) onUpdate(sql, ds, body);
	});else res(TOTEM.errors.noID);
}

/*
function selectDS(req,res) {	//&lt; Default virtual table logic is real table
/ **
 * @private
 * @method deleteDS
 * @param {Object} req Totem's request
 * @param {Function} res Totem's response callback
 * * /
	if (TOTEM.mysql)
		req.sql.query(&quot;SELECT * FROM ??.??&quot;, [req.group,req.table], function (err,data) {
			res(err || data);
		});
	
	else
		res(TOTEM.errors.noDB);
} */

/*
function updateDS(req,res) {
/ **
 * @private
 * @method updateDS
 * @param {Object} req Totem's request
 * @param {Function} res Totem's response callback
 * * /
	//Log(req.table, TOTEM.byTable);
	
	if ( route = TOTEM.byTable[req.table] )
		route(req, res);
	
	else
		res( TOTEM.errors.noRoute );
} */

/*
function insertDS(req,res) {
/ **
 * @private
 * @method insertDS
 * @param {Object} req Totem's request
 * @param {Function} res Totem's response callback
 * * /
	res( TOTEM.errors.notAllowed );
} */

/*
function deleteDS(req,res) {
/ **
 * @private
 * @method deleteDS
 * @param {Object} req Totem's request
 * @param {Function} res Totem's response callback
 * * /
	res( TOTEM.errors.notAllowed );
}  */

function executeDS(req, res) {
<span id='TOTEM-End_Points-CRUD_Interface-method-executeDS'>	/**
</span>  @private
  @method executeDS
  @param {Object} req Totem's request
  @param {Function} res Totem's response callback
  */
	res(TOTEM.errors.notAllowed);
}

<span id='TOTEM-Utilities-Configuration_and_Startup'>/**
</span> * @class TOTEM.Utilities.Configuration_and_Startup
 **/

function configService(opts, cb) {
<span id='TOTEM-Utilities-Configuration_and_Startup-method-configService'>	/**
</span>  @private
  @method configService
  @param {Object} opts configuration options following the ENUM.Copy() conventions.
  @param {Function} cb callback(err) after service configured
  Configure JSDB, define site context, then protect, connect, start and initialize this server.
  */

	//TOTEM.extend(opts);
	if (opts) Copy(opts, TOTEM, &quot;.&quot;);

	var name = TOTEM.host.name,
	    paths = TOTEM.paths,
	    site = TOTEM.site;

	Trace(&quot;CONFIG &quot; + name);

	TOTEM.started = new Date();

	Copy(paths.mime.extensions, MIME.types);

	if (mysql = TOTEM.mysql) JSDB.config({ // establish the db agnosticator 
		//emitter: TOTEM.IO.sockets.emit,   // cant set socketio until server started

		reroute: TOTEM.reroute, // db translators

		fetcher: TOTEM.fetcher,

		mysql: Copy({
			opts: {
				host: mysql.host, // hostname 
				user: mysql.user, // username
				password: mysql.pass, // passphrase
				connectionLimit: mysql.sessions || 100, // max simultaneous connections
				//acquireTimeout : 10000, 			// connection acquire timer
				queueLimit: 100, // max concections to queue (0=unlimited)
				waitForConnections: true // allow connection requests to be queued
			}
		}, mysql)
	}, function (err) {
		// derive server vars and site context vars

		if (err) Trace(err);else JSDB.thread(function (sql) {
			Trace(&quot;DERIVE &quot; + name);

			for (var n in mysql) {
				// derive server paths
				if (n in paths) paths[n] = mysql[n];
			}if (name) // derive site context
				TOTEM.setContext(sql, function () {
					protectService(cb || function (err) {
						Trace(err || &quot;STARTED &quot; + name + &quot; ENCRYPTED&quot;, sql);
					});
				});

			//TOTEM.dsAttrs = JSDB.dsAttrs;
			sql.release();
		});
	});else protectService(cb || function (err) {
		Trace(err || &quot;STARTED &quot; + name + &quot; STANDALONE&quot;);
	});

	return TOTEM;
}

function startService(server, cb) {
<span id='TOTEM-Utilities-Configuration_and_Startup-method-startService'>	/**
</span>  @private
  @method startService
  Attach port listener to this server then initialize it.
  @param {Object} server HTTP/HTTP server
  @param {Function} cb callback(err) when started.
  */

	var name = TOTEM.host.name,
	    site = TOTEM.site,
	    onEncrypted = TOTEM.onEncrypted[CLUSTER.isMaster],
	    paths = TOTEM.paths.mysql;

	Trace(&quot;START &quot; + name);

	TOTEM.server = server || { // define server
		listen: function listen() {
			Trace(&quot;NO SERVER&quot;);
		},
		on: function on() {
			Trace(&quot;NO SERVER&quot;);
		}
	};

	if (server &amp;&amp; name) {
		// attach responder
		//server.on(&quot;connection&quot;, simThread);

		server.on(&quot;request&quot;, sesThread);
	} else return cb(TOTEM.errors.noService);

	//TOTEM.flush();  		// flush enum's config callback stack

	if (onEncrypted &amp;&amp; site.urls.socketio) {
		// attach &quot;/socket.io&quot; with SIO and setup connection listeners
		var guestProfile = TOTEM.guestProfile,
		    IO = TOTEM.IO = new SIO(server, {// use defaults but can override ...
			//serveClient: true, // default true to prevent server from intercepting path
			//path: &quot;/socket.io&quot; // default get-url that the client-side connect issues on calling io()
		}),
		    HUBIO = TOTEM.HUBIO = new SIOHUB(); //&lt; Hub fixes socket.io+cluster bug	

		if (IO) {
			// Setup client web-socket support
			Trace(&quot;SOCKETS AT &quot; + IO.path());

			TOTEM.emitter = IO.sockets.emit;

			IO.on(&quot;connect&quot;, function (socket) {
				// Trap every connect				
				//Trace(&quot;ALLOW SOCKETS&quot;);
				socket.on(&quot;select&quot;, function (req) {
					// Trap connect raised on client &quot;select/join request&quot;

					Trace(&quot;CONNECTING &quot; + req.client);
					sqlThread(function (sql) {

						if (newSession = paths.newSession) sql.query(newSession, {
							Client: req.client,
							Connects: 1,
							Location: &quot;unknown&quot;, //req.location,
							//ipAddress: req.ip,
							Joined: new Date(),
							Message: req.message
						});

						if (challenge = paths.challenge) sql.query(challenge, { Client: req.client }, function (err, profs) {

							if (profile = profs[0]) // || guestProfile(sql, req.client) 
								if (profile.Challenge) challengeClient(req.client, profile);
						});

						sql.release();
					});
				});
			});

			/*
   IO.on(&quot;connect_error&quot;, function (err) {
   	Log(err);
   });
   
   IO.on(&quot;disconnection&quot;, function (socket) {
   	Log(&quot;&gt;&gt;DISCONNECT CLIENT&quot;);
   });	*/

			cb(null);
		} else return cb(TOTEM.errors.noSockets);
	} else cb(null);

	// The BUSY interface provides a mean to limit client connections that would lock the 
	// service (down deep in the tcp/icmp layer).  Busy thus helps to thwart denial of 
	// service attacks.  (Alas latest versions do not compile in latest NodeJS.)

	if (BUSY &amp;&amp; TOTEM.busycycle) BUSY.maxLag(TOTEM.busycycle);

	// listening on-routes message

	//Log(TOTEM.cores, TOTEM.doms, CLUSTER.isMaster, server);

	if (TOTEM.cores) {
			// Start for master-workers
			if (CLUSTER.isMaster) {
				// Establish master port
				server.listen(parseInt(TOTEM.doms.master.port), function () {
					// Establish master  TOTEM.masterport
					Trace(&quot;MASTER AT &quot; + site.urls.master);
				});

				CLUSTER.on('exit', function (worker, code, signal) {
					Trace(&quot;CORE&quot; + worker.id + &quot; TERMINATED &quot; + (code || &quot;ok&quot;));
				});

				CLUSTER.on('online', function (worker) {
					Trace(&quot;CORE&quot; + worker.id + &quot; CONNECTED&quot;);
				});

				for (var core = 0; core &lt; TOTEM.cores; core++) {
					worker = CLUSTER.fork();
					//Trace(`FORK core-${worker.id}`);
				}
			} else // Establish worker port			
				server.listen(TOTEM.doms.worker.port, function () {
					//TOTEM.workerport
					Trace(&quot;CORE&quot; + CLUSTER.worker.id + &quot; AT &quot; + site.urls.worker);
				});
	} else // Establish master-only
		server.listen(TOTEM.doms.master.port, function () {
			//TOTEM.workerport
			Trace(&quot;MASTER AT &quot; + site.urls.master);
		});

	if (TOTEM.faultless) {
		// catch core faults
		process.on(&quot;uncaughtException&quot;, function (err) {
			Trace(&quot;FAULTED &quot; + err);
		});

		process.on(&quot;exit&quot;, function (code) {
			Trace(&quot;HALTED &quot; + code);
		});

		for (var signal in TOTEM.guards) {
			process.on(signal, function () {
				Trace(&quot;SIGNALED &quot; + signal);
			});
		}
	}

	if (TOTEM.riddles) initChallenger();

	sqlThread(function (sql) {
		if (CLUSTER.isMaster) initializeService(sql);
		TOTEM.init(sql);
		sql.release();
	});
}

function connectService(cb) {
<span id='TOTEM-Utilities-Configuration_and_Startup-method-connectService'>	/**
</span>  @private
  @method connectService
  If the TOTEM server already connected, inherit the server; otherwise define a suitable http interface (https if encrypted, 
  http if unencrypted), then start and initialize the service.
  @param {Function} cb callback(err) when connected
  */

	var host = TOTEM.host,
	    name = host.name,
	    paths = TOTEM.paths,
	    certs = TOTEM.cache.certs,
	    onEncrypted = TOTEM.onEncrypted[CLUSTER.isMaster],
	    trustStore = TOTEM.trustStore,
	    cert = certs.totem = { // totem service certs
		pfx: FS.readFileSync(&quot;&quot; + paths.certs + name + &quot;.pfx&quot;),
		key: FS.readFileSync(&quot;&quot; + paths.certs + name + &quot;.key&quot;),
		crt: FS.readFileSync(&quot;&quot; + paths.certs + name + &quot;.crt&quot;)
	};

	certs.fetch = { // data fetching certs
		pfx: FS.readFileSync(paths.certs + &quot;fetch.pfx&quot;),
		key: FS.readFileSync(paths.certs + &quot;fetch.key&quot;),
		crt: FS.readFileSync(paths.certs + &quot;fetch.crt&quot;),
		ca: FS.readFileSync(paths.certs + &quot;fetch.ca&quot;),
		_pfx: paths.certs + &quot;fetch.pfx&quot;,
		_crt: paths.certs + &quot;fetch.crt&quot;,
		_key: paths.certs + &quot;fetch.key&quot;,
		_ca: paths.certs + &quot;fetch.ca&quot;,
		_pass: ENV.FETCH_PASS
	};

	//Log( TOTEM.onEncrypted, CLUSTER.isMaster, CLUSTER.isWorker );

	if (onEncrypted) {
		// have encrypted services so start https service
		try {
			// build the trust strore
			Each(FS.readdirSync(paths.certs + &quot;/truststore&quot;), function (n, file) {
				if (file.indexOf(&quot;.crt&quot;) &gt;= 0 || file.indexOf(&quot;.cer&quot;) &gt;= 0) {
					Trace(&quot;TRUSTING &quot; + file);
					trustStore.push(FS.readFileSync(paths.certs + &quot;truststore/&quot; + file, &quot;utf8&quot;));
				}
			});
		} catch (err) {}

		startService(HTTPS.createServer({
			passphrase: host.encrypt, // passphrase for pfx
			pfx: cert.pfx, // pfx/p12 encoded crt and key 
			ca: trustStore, // list of TOTEM.paths authorities (trusted serrver.trust)
			crl: [], // pki revocation list
			requestCert: true,
			rejectUnauthorized: true
			//secureProtocol: CONS.SSL_OP_NO_TLSv1_2
		}), cb);
	} else // unencrpted services so start http service
		startService(HTTP.createServer(), cb);
}

function protectService(cb) {
<span id='TOTEM-Utilities-Configuration_and_Startup-method-protectService'>	/**
</span>  @private
  @method protectService
  Create the server's PKI certs (if they dont exist), setup site urls, then connect, start and initialize this service.  
  @param {Function} cb callback(err) when protected
  */

	var host = TOTEM.host,
	    name = host.name,
	    paths = TOTEM.paths,
	    sock = TOTEM.sockets ? paths.url.socketio : &quot;&quot;,
	    urls = TOTEM.site.urls = TOTEM.cores // establish site urls
	? {
		socketio: sock,
		worker: host.worker,
		master: host.master
	} : {
		socketio: sock,
		worker: host.master,
		master: host.master
	},
	    doms = TOTEM.doms = {
		master: URL.parse(urls.master),
		worker: URL.parse(urls.worker)
	},
	    pfx = &quot;&quot; + paths.certs + name + &quot;.pfx&quot;,
	    onEncrypted = TOTEM.onEncrypted = {
		true: doms.master.protocol == &quot;https:&quot;, //  at master 
		false: doms.worker.protocol == &quot;https:&quot; // at worker
	};

	//Log(onEncrypted, doms);
	Trace(&quot;PROTECTING &quot; + name + &quot; USING &quot; + pfx);

	if (onEncrypted) // derive a pfx cert if protecting an encrypted service
		FS.access(pfx, FS.F_OK, function (err) {

			if (err) createCert(name, host.encrypt, function () {
				connectService(cb);
			});else connectService(cb);
		});else connectService(cb);
}

function stopService() {
<span id='TOTEM-Utilities-Configuration_and_Startup-method-stopService'>	/**
</span>  @private
  @method stopService
  Stop the server.
  */

	var server = TOTEM.server;

	if (server) server.close(function () {
		Trace(&quot;STOPPED&quot;);
	});
}

function initializeService(sql) {
<span id='TOTEM-Utilities-Configuration_and_Startup-method-initializeService'>	/**
</span>  @private
  @method initializeService
  Initialize service, file watchers and start watch dogs.
  @param {Object} sql connectors
 */
	var site = TOTEM.site;

	Trace([// splash
	&quot;HOSTING &quot; + site.nick, &quot;AT &quot; + site.urls.master, &quot;USING &quot; + site.db, &quot;FROM &quot; + process.cwd(), &quot;WITH &quot; + (site.urls.socketio || &quot;NO&quot;) + &quot; SOCKETS&quot;, &quot;WITH &quot; + (TOTEM.faultless ? &quot;GUARDED&quot; : &quot;UNGUARDED&quot;) + &quot; THREADS&quot;, &quot;WITH &quot; + (TOTEM.riddles ? &quot;ANTIBOT&quot; : &quot;NO ANTIBOT&quot;) + &quot; PROTECTION&quot;, &quot;WITH &quot; + (site.sessions || &quot;UNLIMITED&quot;) + &quot; CONNECTIONS&quot;, &quot;WITH &quot; + (TOTEM.cores ? TOTEM.cores + &quot; WORKERS AT &quot; + site.urls.worker : &quot;NO WORKERS&quot;)].join(&quot;\n- &quot;));

	// initialize file watcher

	sql.query(&quot;UPDATE app.files SET State='watching' WHERE Area='uploads' AND State IS NULL&quot;);

	var mTimes = TOTEM.mTimes;

	Each(TOTEM.onFile, function (area, cb) {
		// callback cb(sql,name,area) when file changed
		FS.readdir(area, function (err, files) {
			if (err) Log(err);else files.each(function (n, file) {
				var first = file.charAt(0);

				if (first != &quot;.&quot; &amp;&amp; first != &quot;_&quot;) TOTEM.watchFile(area + file, cb);
			});
		});
	});

	// start watch dogs

	Each(TOTEM.dogs, function (key, dog) {
		if (dog.cycle) {
			// attach sql threaders and setup watchdog interval
			//Trace(&quot;DOGING &quot;+key);
			dog.trace = dog.name.toUpperCase();
			dog.forEach = JSDB.forEach;
			dog.forAll = JSDB.forAll;
			dog.forFirst = JSDB.forFirst;
			dog.thread = JSDB.thread;
			dog.site = TOTEM.site;

			setInterval(function (args) {

				//Trace(&quot;DOG &quot;+args.name);

				dog(dog); // feed dog attributes as parameters
			}, dog.cycle * 1e3, {
				name: key
			});
		}
	});
}
<span id='TOTEM-End_Points-User_Managment'>/**
</span>@class TOTEM.End_Points.User_Managment
Legacy endpoints to manage users and their profiles.  Moved to FLEX.
 */

function selectUser(req, res) {
<span id='TOTEM-End_Points-User_Managment-method-selectUser'>	/**
</span> @private
 @deprecated
 @method selectUser
 Return user profile information
 @param {Object} req Totem session request 
 @param {Function} res Totem response
  */

	var sql = req.sql,
	    query = req.query || 1,
	    isHawk = req.cert.isHawk;

	isHawk = 1;
	if (isHawk) Trace(sql.query(&quot;SELECT * FROM openv.profiles WHERE least(?,1)&quot;, [query], function (err, users) {
		res(err || users);
	}).sql);else sql.query(&quot;SELECT * FROM openv.profiles WHERE ? AND least(?,1)&quot;, [{ client: req.client }, req.query], function (err, users) {
		res(err || users);
	});
}

function updateUser(req, res) {
<span id='TOTEM-End_Points-User_Managment-method-updateUser'>	/**
</span> @private
 @deprecated
 @method updateUser
 Update user profile information
 @param {Object} req Totem session request 
 @param {Function} res Totem response
  */

	var sql = req.sql,
	    query = req.query,
	    isHawk = req.cert.isHawk;

	if (sql.query) {
		if (isHawk)
			// sql.context({users:{table:&quot;openv.profile&quot;,where:{client:query.user},rec:query}});
			Trace(sql.query(&quot;UPDATE openv.profiles SET ? WHERE ?&quot;, [query, { client: query.user }], function (err, info) {
				res(err || TOTEM.errors.failedUser);
			}).sql);else sql.query(&quot;UPDATE openv.profiles SET ? WHERE ?&quot;, [query, { client: req.client }], function (err, info) {

			res(err || TOTEM.errors.failedUser);
		});
	} else res(TOTEM.errors.failedUser);
}

function deleteUser(req, res) {
<span id='TOTEM-End_Points-User_Managment-method-deleteUser'>	/**
</span> @private
 @deprecated
 @method deleteUser
 Remove user profile.
 @param {Object} req Totem session request 
 @param {Function} res Totem response
  */

	var sql = req.sql,
	    query = req.query,
	    isHawk = req.cert.isHawk;

	if (query) {
		if (isHawk)
			// sql.context({users:{table:&quot;openv.profiles&quot;,where:[ {client:query.user}, req.query ],rec:res}});
			Trace(sql.query(&quot;TEST FROM openv.profiles WHERE ? AND least(?,1)&quot;, [{ client: query.user }, req.query], function (err, info) {
				res(err || TOTEM.errors.failedUser);

				// res should remove their files and other 
				// allocated resources
			}).sql);else sql.query(&quot;TEST FROM openv.profiles WHERE ? AND least(?,1)&quot;, [{ client: req.client }, req.query], function (err, info) {
			res(err || TOTEM.errors.failedUser);
		});
	} else res(TOTEM.errors.failedUser);
}

function insertUser(req, res) {
<span id='TOTEM-End_Points-User_Managment-method-insertUser'>	/**
</span> @private
 @deprecated
 @method insertUser
 Create user profile, associated certs and distribute info to user
 @param {Object} req Totem session request 
 @param {Function} res Totem response
  */

	var sql = req.sql,
	    query = req.query || {},
	    isHawk = req.cert.isHawk,
	    url = TOTEM.paths.url;

	if (req.cert.isHawk) {
		if (query.pass) sql.query(&quot;SELECT * FROM openv.profiles WHERE Requested AND NOT Approved AND least(?,1)&quot;, query.user ? { User: query.user } : 1).on(&quot;result&quot;, function (user) {
			var init = Copy({
				Approved: new Date(),
				Banned: url.resetpass ? &quot;Please &quot; + &quot;reset your password&quot;.tag(&quot;a&quot;, { href: url.resetpass }) + &quot; to access&quot; : &quot;&quot;,

				Client: user.User,
				QoS: 0,

				Message: (&quot;Greetings from &quot; + site.Nick.tag(&quot;a&quot;, { href: site.urls.master }) + &quot;-\n\nAdmin:\n\tPlease create an AWS EC2 account for &quot; + owner + &quot; using attached cert.\n\nTo connect to &quot; + site.Nick + &quot; from Windows:\n\n1. Establish gateway using \n\n\t\tPutty | SSH | Tunnels\n\t\t\n\twith the following LocalPort, RemotePort map:\n\t\n\t\t5001, &quot; + site.urls.master + &quot;:22\n\t\t5100, &quot; + site.urls.master + &quot;:3389\n\t\t5200, &quot; + site.urls.master + &quot;:8080\n\t\t5910, &quot; + site.urls.master + &quot;:5910\n\t\t5555, Dynamic\n\t\n\tand, for convienience:\n\n\t\tPageant | Add Keys | your private ppk cert\n\n2. Start a &quot; + site.Nick + &quot; session using one of these methods:\n\n\t&quot; + Putty + &quot; | Session | Host Name = localhost:5001 \n\tRemote Desktop Connect| Computer = localhost:5100 \n\t&quot; + FF + &quot; | Options | Network | Settings | Manual Proxy | Socks Host = localhost, Port = 5555, Socks = v5 &quot;).replace(/\n/g, &quot;&lt;br&gt;&quot;)

			}, Copy(TOTEM.guestProfile, {}));

			sql.query(&quot;UPDATE openv.profiles SET ? WHERE ?&quot;, [init, { User: user.User }], function (err) {

				createCert(user.User, pass, function () {

					Trace(&quot;CREATE CERT FOR &quot; + user.User, sql);

					CP.exec(&quot;sudo adduser &quot; + user.User + &quot; -gid &quot; + user.Group + &quot;; sudo id &quot; + user.User, function (err, out) {

						sql.query(&quot;UPDATE openv.profiles SET ? WHERE ?&quot;, [{ uid: out }, { User: user.User }]);

						Log(err ? &quot;Account failed for &quot; + user.User + &quot; - require \&quot;sudo adduser\&quot; to protect this service&quot; : &quot;Account created and group rights assigned to &quot; + user.User);
					});
				});
			});
		}).on(&quot;end&quot;, function () {
			res(&quot;User creation working&quot;);
		});else res(TOTEM.errors.missingPass);
	} else sql.query(&quot;INSERT openv.profiles SET ? WHERE ?&quot;, [req.query, { User: req.User }], function (err, info) {

		res(err || TOTEM.errors.failedUser);
	});
}

function executeUser(req, res) {
<span id='TOTEM-End_Points-User_Managment-method-executeUser'>	/**
</span> @private
 @deprecated
 @method executeUser
 Fetch user profile for processing
 @param {Object} req Totem session request 
 @param {Function} res Totem response
 */
	var access = TOTEM.user,
	    query = req.query;

	query.user = query.user || query.select || query.delete || query.update || query.insert;

	if (access) {
		for (var n in { select: 1, delete: 1, update: 1, insert: 1 }) {
			if (query[n]) {
				delete query[n];
				return access[n](req, res);
			}
		}if (call = query.call) {
			delete query.call;
			return access[call](req, res);
		}
	}

	res(TOTEM.errors.failedUser);
}

<span id='TOTEM-Utilities-PKI_Certs'>/**
</span>@class TOTEM.Utilities.PKI_Certs
Utilities to create and manage PKI certs
 */

function createCert(owner, pass, cb) {
<span id='TOTEM-Utilities-PKI_Certs-method-createCert'>	/**
</span> @private
 @method createCert
 Create a cert for the desired owner with the desired passphrase then callback cb() when complete.
 @param {String} owner userID to own this cert
 @param {String} password for this cert
 @param {Function} cb callback when completed
 */

	function traceExecute(cmd, cb) {

		Trace(cmd.replace(/\n/g, &quot;\\n&quot;));

		CP.exec(cmd, function (err) {

			if (err) console.info({
				shell: cmd,
				error: err
			});

			cb();
		});
	}

	var paths = TOTEM.paths,
	    name = &quot;&quot; + paths.certs + owner,
	    truststore = paths.certs + &quot;truststore&quot;,
	    pfx = name + &quot;.pfx&quot;,
	    key = name + &quot;.key&quot;,
	    crt = name + &quot;.crt&quot;,
	    ppk = name + &quot;.ppk&quot;;

	Trace(&quot;CREATE SELF-SIGNED SERVER CERT FOR &quot; + owner);

	traceExecute(&quot;echo -e \&quot;\n\n\n\n\n\n\n\&quot; | openssl req -x509 -nodes -days 5000 -newkey rsa:2048 -keyout &quot; + key + &quot; -out &quot; + crt, function () {

		traceExecute(&quot;export PASS=\&quot;&quot; + pass + &quot;\&quot;;openssl pkcs12 -export -in &quot; + crt + &quot; -inkey &quot; + key + &quot; -out &quot; + pfx + &quot; -passout env:PASS&quot;, function () {

			traceExecute(&quot;cp &quot; + crt + &quot; &quot; + truststore, function () {

				traceExecute(&quot;puttygen &quot; + owner + &quot;.key -N &quot; + pass + &quot; -o &quot; + ppk, function () {

					Trace(&quot;IGNORE PUTTYGEN ERRORS IF NOT INSTALLED&quot;);
					cb();
				});
			});
		});
	});
}

function validateClient(req, res) {
<span id='TOTEM-Utilities-PKI_Certs-method-validateClient'>	/**
</span> @private
 @method validateClient
 
 Attaches log, profile, group, client, cert and joined info to this req request (sql, reqSocket) with callback res(error) where
 error is null if session is admitted by admitClient.  
 
 @param {Object} req totem request
 @param {Function} res totem response
 */

	function getCert(sock) {
		//&lt; Return cert for https/http connection on this socket (w or w/o proxy).
		var cert = sock ? sock.getPeerCertificate ? sock.getPeerCertificate() : null : null;

		if (TOTEM.behindProxy) {
			// update cert with originating cert info that was placed in header
			var cert = new Object(cert),
			    // clone so we can modify
			NA = Req.headers.ssl_client_notafter,
			    NB = Req.headers.sll_client_notbefore,
			    DN = Req.headers.ssl_client_s_dn;

			if (NA) cert.valid_to = new Date([NA.substr(2, 2), NA.substr(4, 2), NA.substr(0, 2)].join(&quot;/&quot;) + &quot; &quot; + [NA.substr(6, 2), NA.substr(8, 2), NA.substr(10, 2)].join(&quot;:&quot;));

			if (NB) cert.valid_to = new Date([NB.substr(2, 2), NB.substr(4, 2), NB.substr(0, 2)].join(&quot;/&quot;) + &quot; &quot; + [NB.substr(6, 2), NB.substr(8, 2), NB.substr(10, 2)].join(&quot;:&quot;));

			if (DN) Each(DN.split(&quot;/&quot;), function (n, hdr) {
				if (hdr) {
					var sub = hdr.split(&quot;=&quot;);
					cert.subject[sub[0]] += sub[1];
				}
			});

			if (CN = cert.subject.CN) {
				CN = CN.split(&quot; &quot;);
				cert.subject.CN = CN[CN.length - 1] + &quot;@lost.org&quot;;
			}
		}

		return cert;
	}

	var sql = req.sql,
	    cert = req.encrypted ? getCert(req.reqSocket) : null,
	    certs = TOTEM.cache.certs,
	    guest = &quot;guest@guest.org&quot;,
	    paths = TOTEM.paths.mysql,
	    errors = TOTEM.errors,
	    admitClient = TOTEM.admitClient;

	req.cert = certs[req.client] = cert ? new Object(cert) : null;
	req.joined = new Date();
	req.client = cert ? (cert.subject.emailAddress || cert.subjectaltname || cert.subject.CN || guest).split(&quot;,&quot;)[0].replace(&quot;email:&quot;, &quot;&quot;) : guest;

	if (TOTEM.mysql) // derive client's profile from db
		sql.query(paths.getProfile, { client: req.client }, function (err, profs) {

			if (profile = profs[0] || makeGuest(sql, req.client)) admitClient(req, profile, res);else res(errors.rejectedClient);
		});else if (req.encrypted) // db required on encrypted service
		res(errors.noDB);else if (profile = makeGuest(sql, req.client)) {
		// guests allowed
		//req.socket = null;
		req.reqSocket = null; // disable guest session metrics
		admitClient(req, profile, res);
	} else res(errors.rejectedClient);
}

<span id='TOTEM-Utilities-File_Access'>/**
</span>@class TOTEM.Utilities.File_Access
File cacheing, indexing and uploading
 */

function indexFile(path, cb) {
<span id='TOTEM-Utilities-File_Access-method-indexFile'>	/**
</span> @private
 @method indexFile
 @param {String} path file path
 @param {Function} cb totem response
 */
	function findFile(path, cb) {
<span id='TOTEM-Utilities-File_Access-method-findFile'>		/**
</span>  @private
  @method findFile
  @param {String} path file path
  @param {Function} cb totem response
  */
		try {
			FS.readdirSync(path).forEach(function (file) {
				if (file.charAt(0) != &quot;_&quot; &amp;&amp; file.charAt(file.length - 1) != &quot;~&quot;) cb(file);
			});
		} catch (err) {}
	}

	var files = [],
	    maxIndex = TOTEM.maxIndex;

	findFile(path, function (file) {
		if (files.length &lt; maxIndex) files.push(file.indexOf(&quot;.&quot;) &lt; 0 ? file + &quot;/&quot; : file);
	});

	cb(files);
}

function getFile(client, name, cb) {
<span id='TOTEM-Utilities-File_Access-method-getFile'>	/**
</span> @private
 @method getFile
 Get (or create if needed) a file with callback cb(fileID, sql) if no errors
 @param {String} client owner of file
 @param {String} name of file to get/make
 @param {Function} cb callback(area, fileID, sql) if no errors
 */

	JSDB.forFirst(&quot;FILE&quot;, &quot;SELECT ID FROM app.files WHERE least(?,1) LIMIT 1&quot;, {
		Name: name
		//Client: client,
		//Area: area
	}, function (file, sql) {

		if (file) cb(file.ID, sql);else sql.forAll(&quot;FILE&quot;, &quot;INSERT INTO app.files SET _State_Added=now(), ?&quot;, {
			Name: name,
			Client: client
			// Path: filepath,
			// Area: area
		}, function (info) {
			cb(info.insertId, sql);
		});
	});
}

function uploadFile(client, srcStream, sinkPath, tags, cb) {
<span id='TOTEM-Utilities-File_Access-method-uploadFile'>	/**
</span> @private
 @method uploadFile
 Uploads a source stream srcStream to a target file sinkPath owned by a 
 specified client.  Optional tags are logged with the upload.
 @param {String} client file owner
 @param {Stream} source stream
 @param {String} sinkPath path to target file
 @param {Object} tags hach of tags to add to file
 @param {Function} cb callback(fileID) if no errors encountered
 */
	var parts = sinkPath.split(&quot;/&quot;),
	    name = parts.pop() || &quot;&quot;;

	getFile(client, name, function (fileID, sql) {
		var sinkStream = FS.createWriteStream(sinkPath, &quot;utf8&quot;).on(&quot;finish&quot;, function () {
			// establish sink stream for export pipe

			Trace(&quot;UPLOADED FILE&quot;);
			sqlThread(function (sql) {

				sql.query(&quot;UPDATE apps.files SET ? WHERE ?&quot;, [{
					_Ingest_Tag: JSON.stringify(tags || null),
					_State_Notes: &quot;Please go &quot; + &quot;here&quot;.tag(&quot;a&quot;, { href: &quot;/files.view&quot; }) + &quot; to manage your holdings.&quot;
				}, { ID: fileID }]);

				sql.release();
			});
		}).on(&quot;error&quot;, function (err) {
			Log(&quot;totem upload error&quot;, err);
			sqlThread(function (sql) {
				sql.query(&quot;UPDATE app.files SET ? WHERE ?&quot;, [{
					_State_Notes: &quot;Upload failed: &quot; + err
				}, { ID: fileID }]);

				sql.release();
			});
		});

		Log(&quot;uploading to&quot;, sinkPath);

		if (cb) cb(fileID); // callback if provided

		if (srcStream) // if a source stream was provided, start pipe to copy source to sink
			srcStream.pipe(sinkStream);
	});
}

<span id='TOTEM-Utilities-Antibot_Protection'>/**
</span>@class TOTEM.Utilities.Antibot_Protection
Data theft protection
 */

function sysValidate(req, res) {
	//&lt; endpoint to check clients response to a riddle
<span id='TOTEM-Utilities-Antibot_Protection-method-sysValidate'>	/**
</span> @private
 @method sysValidate
 Endpoint to check clients response req.query to a riddle created by challengeClient.
 @param {Object} req Totem session request
 @param {Function} res Totem response callback
 */
	var query = req.query,
	    sql = req.sql,
	    id = query.ID || query.id;

	if (id) sql.query(&quot;SELECT * FROM openv.riddles WHERE ? LIMIT 1&quot;, { Client: id }, function (err, rids) {

		if (rid = rids[0]) {
			var ID = { Client: rid.ID },
			    guess = (query.guess + &quot;&quot;).replace(/ /g, &quot;&quot;);

			Log([rid, query]);

			if (rid.Riddle == guess) {
				res(&quot;pass&quot;);
				sql.query(&quot;DELETE FROM openv.riddles WHERE ?&quot;, ID);
			} else if (rid.Attempts &gt; rid.maxAttempts) {
				res(&quot;fail&quot;);
				sql.query(&quot;DELETE FROM openv.riddles WHERE ?&quot;, ID);
			} else {
				res(&quot;retry&quot;);
				sql.query(&quot;UPDATE openv.riddles SET Attempts=Attempts+1 WHERE ?&quot;, ID);
			}
		} else res(TOTEM.errors.noSession);
	});else res(TOTEM.errors.noID);
}

function initChallenger() {
<span id='TOTEM-Utilities-Antibot_Protection-method-initChallenger'>	/**
</span> @private
 @method initChallenger
 Create a set of TOTEM.riddles challenges.
 */
	function Riddle(map, ref) {
		var Q = {
			x: Math.floor(Math.random() * 10),
			y: Math.floor(Math.random() * 10),
			z: Math.floor(Math.random() * 10),
			n: Math.floor(Math.random() * map[&quot;0&quot;].length)
		},
		    A = {
			x: &quot;&quot;.tag(&quot;img&quot;, { src: ref + &quot;/&quot; + Q.x + &quot;/&quot; + map[Q.x][Q.n] + &quot;.jpg&quot; }),
			y: &quot;&quot;.tag(&quot;img&quot;, { src: ref + &quot;/&quot; + Q.y + &quot;/&quot; + map[Q.y][Q.n] + &quot;.jpg&quot; }),
			z: &quot;&quot;.tag(&quot;img&quot;, { src: ref + &quot;/&quot; + Q.z + &quot;/&quot; + map[Q.z][Q.n] + &quot;.jpg&quot; })
		};

		return {
			Q: A.x + &quot; * &quot; + A.y + &quot; + &quot; + A.z,
			A: Q.x * Q.y + Q.z
		};
	}

	var riddle = TOTEM.riddle,
	    N = TOTEM.riddles,
	    map = TOTEM.riddleMap,
	    ref = &quot;/captcha&quot;;

	for (var n = 0; n &lt; N; n++) {
		riddle.push(Riddle(map, ref));
	}
}

function makeRiddles(msg, rid, ids) {
	//&lt; turn msg with riddle markdown into a riddle
<span id='TOTEM-Utilities-Antibot_Protection-method-sysValidate'>	/**
</span> @private
 @method sysValidate
 Endpoint to check clients response req.query to a riddle created by challengeClient.
 @param {String} msg riddle mask contianing (riddle), (yesno), (ids), (rand), (card), (bio) keys
 @param {Array} rid List of riddles returned
 @param {Object} ids Hash of {id: value, ...} replaced by (ids) key
 */
	var riddles = TOTEM.riddle,
	    N = riddles.length;

	if (N) return msg.replace(/\(riddle\)/g, function (pat) {
		var QA = riddles[Math.floor(Math.random() * N)];
		rid.push(QA.A);
		return QA.Q;
	}).replace(/\(yesno\)/g, function (pat) {
		var QA = riddles[Math.floor(Math.random() * N)];
		rid.push(QA.A);
		return QA.Q;
	}).replace(/\(ids\)/g, function (pat) {
		var rtn = [];
		Each(ids, function (key, val) {
			rtn.push(key);
			rid.push(val);
		});
		return rtn.join(&quot;, &quot;);
	}).replace(/\(rand\)/g, function (pat) {
		rid.push(Math.floor(Math.random() * 10));
		return &quot;random integer between 0 and 9&quot;;
	}).replace(/\(card\)/g, function (pat) {
		return &quot;cac card challenge TBD&quot;;
	}).replace(/\(bio\)/g, function (pat) {
		return &quot;bio challenge TBD&quot;;
	});else return msg;
}

function challengeClient(client, profile) {
	//&lt; create a challenge and rely it to the client
<span id='TOTEM-Utilities-Antibot_Protection-method-challengeClient'>	/**
</span> @private
 @method challengeClient
 Challenge a client with specified profile parameters
 @param {String} client being challenged
 @param {Object} profile with a .Message riddle mask and a .IDs = {key:value, ...}
 */
	var rid = [],
	    reply = TOTEM.riddleMap &amp;&amp; TOTEM.riddles ? makeRiddles(profile.Message, rid, (profile.IDs || &quot;&quot;).parseJSON({})) : profile.Message;

	if (reply &amp;&amp; TOTEM.IO) sqlThread(function (sql) {
		sql.query(&quot;REPLACE INTO openv.riddles SET ?&quot;, {
			Riddle: rid.join(&quot;,&quot;).replace(/ /g, &quot;&quot;),
			Client: client,
			Made: new Date(),
			Attempts: 0,
			maxAttempts: profile.Retries
		}, function (err, info) {

			TOTEM.IO.emit(&quot;select&quot;, {
				message: reply,
				riddles: rid.length,
				rejected: false,
				retries: profile.Retries,
				timeout: profile.Timeout,
				ID: client, //info.insertId,
				callback: TOTEM.paths.url.riddler
			});

			sql.release();
		});
	});
}

<span id='TOTEM-Utilities-Endpoint_Routing'>/**
</span>@class TOTEM.Utilities.Endpoint_Routing 
Methods to route notes byType, byAction, byTable, byActionTable, byArea.
*/

function parseNode(req) {
<span id='TOTEM-Utilities-Endpoint_Routing-method-parseNode'>	/**
</span> @private
 @method parseNode
 Parse node request req.node = /TABLE?QUERY&amp;INDEX || /FILEAREA/FILENAME to define 
 the req .table, .path, .filearea, .filename, .type and the req .query, .index, .joins and .flags.
 @param {Object} req Totem session request
 */
	var query = req.query = {},
	    index = req.index = {},
	    where = req.where = {},
	    flags = req.flags = {},
	    path = req.path = &quot;.&quot; + req.node.parsePath(query, index, flags, where),
	    //  ./area1/area2/.../table.type
	areas = path.split(&quot;/&quot;),
	    // [&quot;.&quot;, area1, area2, ...]
	file = req.file = areas.pop() || &quot;&quot;,
	    // table.type
	parts = file.split(&quot;.&quot;),
	    // [table, type, ...]
	table = req.table = parts[0] || &quot;&quot;,
	    type = req.type = parts[1] || &quot;&quot;,
	    area = req.area = areas[1] || &quot;&quot;,
	    site = req.site = TOTEM.site;

	//Log(&quot;&gt;&gt;&gt;&gt;&gt;&quot;, path, &quot;&gt;&gt;&gt;&gt;&quot;, query);
	//Log(path,areas,area);

	var reqFlags = TOTEM.reqFlags,
	    strips = reqFlags.strips,
	    prefix = reqFlags.prefix,
	    traps = reqFlags.traps,
	    id = reqFlags.id,
	    body = req.body;

	/*
 Log({before: {
 	a: req.action,
 	q: query,
 	b: body,
 	f: flags
 }}); */

	for (var key in query) {
		// strip or remap bogus keys
		if (key in strips) delete query[key];
	}for (var key in body) {
		// remap body flags
		if (key.charAt(0) == prefix) {
			flags[key.substr(1)] = body[key];
			delete body[key];
		}
	}if (id in body) {
		// remap body record id
		query[id] = body[id];
		delete body[id];
	}

	/*
 Log({after: {
 	a: req.action,
 	q: query,
 	b: body,
 	f: flags
 }}); */
}

function routeNodes(nodes, acks, req, res) {
<span id='TOTEM-Utilities-Endpoint_Routing-method-routeNodes'>	/**
</span> @private
 @method routeNodes
 Submit nodes=[/dataset.type, /dataset.type ...]  on the current request thread req to the routeNode() 
 method, aggregate results, then send with supplied response().
 @param {Array} nodes
 @param {Object} acks
 @param {Object} req Totem session request
 @param {Function} res Totem response callback
 */

	if (node = req.node = nodes.pop()) // grab last node
		routeNode(req, function (ack) {
			// route it and intercept its ack
			acks[req.table] = ack;
			routeNodes(nodes, acks, Copy(req, {}), res);
		});else if (nodes.length) // still more nodes
		routeNodes(nodes, acks, Copy(req, {}), res);else // no more nodes
		res(acks);
}

function routeNode(req, res) {
<span id='TOTEM-Utilities-Endpoint_Routing-method-routeNode'>	/**
</span> @private
 @method routeNode
 
 Parse the node=/dataset.type on the current req thread, then route using byArea, byType, byTable,
 byActionTable, or byAction routers.
 
 @param {Object} req Totem session request
 @param {Function} res Totem response callback
 */

	parseNode(req);

	function sendFile(req, res) {
		res(function () {
			return req.path;
		});
	}

	function followRoute(route, req, res) {
<span id='TOTEM-Utilities-Endpoint_Routing-method-followRoute'>		/**
</span>  @private
  @method followRoute
  	Log session metrics, trace the current route, then callback route on the supplied 
  request-response thread
  	@param {Function} route method endpoint to process session 
  @param {Object} req Totem session request
  @param {Function} res Totem response callback
  */

		function logMetrics(log, sock) {
			//&lt; log session metrics 
			if (logMetrics = TOTEM.paths.mysql.logMetrics) {

				sock._started = new Date();

				/*
    If maxlisteners is not set to infinity=0, the connection becomes sensitive to a sql 
    connector t/o and there will be random memory leak warnings.
    */

				sock.setMaxListeners(0);
				sock.on('close', function () {
					// cb when connection closed
					var secs = sock._started ? (new Date().getTime() - sock._started.getTime()) / 1000 : 0,
					    bytes = sock.bytesWritten;
					//log = req.log;

					sqlThread(function (sql) {

						sql.query(logMetrics, [Copy(log, {
							Delay: secs,
							Transfer: bytes,
							Event: sock._started,
							Dataset: &quot;&quot;,
							Client: req.client,
							Actions: 1
						}), bytes, secs, log.Event]);

						sql.release();
					});
				});
			}
		}

		if (!req.area &amp;&amp; req.encrypted) // log if file path unspecified
			if (sock = req.reqSocket) // log if http request socket
				if (log = req.log) // log if logging enabled
					logMetrics(log, sock);

		var myid = CLUSTER.isMaster ? 0 : CLUSTER.worker.id;

		Trace((route.name || &quot;db&quot; + req.action).toUpperCase() + (&quot; &quot; + req.file + &quot; FOR &quot; + req.client + &quot; ON CORE&quot; + myid), req.sql);

		route(req, res);

		/*
  if ( CLUSTER.isWorker || !TOTEM.cores ) {
  }
  else
  if (route.name == &quot;simThread&quot;)
  	route(req,res);
  	else
  	res(TOTEM.errors.noAccess);
  */
	}

	var sql = req.sql,
	    node = req.node,
	    table = req.table,
	    type = req.type,
	    action = req.action,
	    area = req.area,
	    path = req.path,
	    paths = TOTEM.paths;

	//Log([action,path,area,table,type]);

	if (area) {
		if (route = TOTEM.byArea[area]) followRoute(route, req, res);else followRoute(sendFile, req, res);
	} else if (route = TOTEM.byType[type]) followRoute(route, req, res);else if (route = TOTEM.byActionTable[action][table]) followRoute(route, req, res);else if (route = TOTEM.byTable[table]) followRoute(route, req, res);else // attempt to route to engines then to database
		if (route = TOTEM.byAction[action]) route(req, function (ack) {
			//Log({engroute: ack});

			if (ack) res(ack);else if (route = TOTEM[action]) {
				if (TOTEM.cache.learnedTables) followRoute(TOTEM.byActionTable[action][table] = route, req, res);else followRoute(route, req, res);
			} else res(TOTEM.errors.noRoute);
		});else if (route = TOTEM[action]) followRoute(route, req, res);else res(TOTEM.errors.noRoute);
}

<span id='TOTEM-Utilities-Thread_Processing'>/**
</span>@class TOTEM.Utilities.Thread_Processing
sql and session thread processing
*/

function sesThread(Req, Res) {
<span id='TOTEM-Utilities-Thread_Processing-method-sesThread'>	/**
</span> @method sesThread
 
 Creates a HTTP/HTTPS request-repsonse session thread, then uses the byTable, byArea, 
 byType, byActionTable config to route this thread to the appropriate (req,res)-endpoint.
 The newly formed request req contains:
 
 		method: &quot;GET, ... &quot; 		// http method and its ...
 		action: &quot;select, ...&quot;,		// corresponding crude name
 		socketio: &quot;path&quot;  // filepath to client's socketio.js
 		where: {...}, 		// sql-ized query keys from url
 		body: {...},		// body keys from request 
 		flags: {...}, 		// flag keys from url
 		index: {...}		// sql-ized index keys from url
 		query: {...}, 		// raw keys from url
 		files: [...] 		// files uploaded
 		site: {...}			// skinning context keys
 		sql: connector 		// sql database connector (dummy if no mysql config)
 		url	: &quot;url&quot;				// complete &quot;/area/.../name.type?query&quot; url
 		search: &quot;query&quot;		// query part
 		path: &quot;/...&quot;			// path part 
 		filearea: &quot;area&quot;		// area part
 		filename: &quot;name&quot;	// name part
 		type: &quot;type&quot; 			// type part 
 		connection: socket		// http/https socket to retrieve client cert 
 
 The newly formed response res method accepts a string, an objects, an array, an error, or 
 a file-cache function to appropriately respond and close this thread and its sql connection.  
 The session is validated and logged, and the client is challenged as necessary.
 
 @param {Object} Req http/https request
 @param {Object} Res http/https response
  */

	// Session terminating functions to respond with a string, file, db structure, or error message.

	function sendString(data) {
		// Send string
		Res.end(data);
		Req.req.sql.release();
	}

	function sendFile(path, file, type, area) {
		// Cache and send file to client

		// Trace(`SENDING ${path}`);

		var cache = TOTEM.cache;

		if (cache.never[file] || cache.never[type]) cache = null;
		if (cache) cache = cache[area];
		if (cache) cache = cache[type];

		var buf = cache ? cache[path] : null;

		if (buf) sendString(buf);else FS.readFile(path, function (err, buf) {
			if (err) sendError(TOTEM.errors.noFile);else if (cache) sendString(cache[path] = buf);else sendString(buf);
		});
	}

	function sendError(err) {
		// Send pretty error message
		Res.end(TOTEM.errors.pretty(err));
		Req.req.sql.release();
	}

	function sendObject(obj) {
		try {
			sendString(JSON.stringify(obj));
		} catch (err) {
			sendErrror(errors.noData);
		}
	}

	function sendRecords(recs, req) {
		// Send records via converter
		var reqTypes = TOTEM.reqTypes,
		    errors = TOTEM.errors;

		if (recs) {
			if (conv = reqTypes[req.type]) // process record conversions
				conv(recs, req, function (rtn) {

					if (rtn) switch (rtn.constructor) {
						case Error:
							sendError(rtn);
							break;

						case String:
							sendString(rtn);
							break;

						case Array:
						case Object:
						default:
							sendObject(rtn);
					} else sendError(errors.noData);
				});else sendObject(recs);
			//sendError( errors.badType );

		} else sendErrror(errors.noData);
	}

	function res(ack) {
		// Session response callback

		var req = Req.req,
		    sql = req.sql,
		    errors = TOTEM.errors,
		    mime = isError(ack || 0) ? MIME.types.html : MIME.types[req.type] || MIME.types.html || &quot;text/plain&quot;,
		    paths = TOTEM.paths;

		Res.setHeader(&quot;Content-Type&quot;, mime);
		Res.statusCode = 200;

		if (ack) switch (ack.constructor) {// send ack based on its type
			case Error:
				// send error message

				switch (req.type) {
					case &quot;db&quot;:
						sendString(JSON.stringify({
							success: false,
							msg: ack + &quot;&quot;,
							count: 0,
							data: []
						}));
						break;

					default:
						sendError(ack);
				}
				break;

			case Function:
				// send file via search or direct

				if ((search = req.query.search) &amp;&amp; paths.mysql.search) // search for file via nlp/etc
					sql.query(paths.mysql.search, { FullSearch: search }, function (err, files) {

						if (err) sendError(errors.noFile);else sendError(errors.noFile); // reserved functionality
					});else {
					if (credit = paths.mysql.credit) // credit/charge client when file pulled from file system
						sql.query(credit, { Name: req.node, Area: req.area }).on(&quot;result&quot;, function (file) {
							if (file.Client != req.client) sql.query(&quot;UPDATE openv.profiles SET Credit=Credit+1 WHERE ?&quot;, { Client: file.Client });
						});

					sendFile(ack(), req.file, req.type, req.area);
				}

				break;

			case Array:
				// send data records 

				var flag = TOTEM.reqFlags;

				if (req.flags.blog) // blog back selected keys
					flag.blog(ack, req, function (recs) {
						sendRecords(recs, req);
					});else if (req.flags.encap) // encap selected keys
					flag.encap(ack, req, function (recs) {
						sendRecords(recs, req);
					});else sendRecords(ack, req);

				break;

			case String: // send message
			case Buffer:
				sendString(ack);
				break;

			case Object:
			default:
				// send data record
				sendObject(ack);
				break;

		} else sendError(errors.noData);
	}

	function getBody(cb) {
		// Feed body and file parameters to callback

		var body = &quot;&quot;;

		Req.on(&quot;data&quot;, function (chunk) {
			body += chunk.toString();
		}).on(&quot;end&quot;, function () {
			if (body) cb(body.parseJSON(function (body) {
				// yank files if body not json

				var files = [],
				    parms = {};

				body.split(&quot;\r\n&quot;).each(function (n, line) {
					if (line) if (parms.type) {
						// type was defined so have the file data
						files.push(Copy(parms, { data: line, size: line.length }));
						parms = {};
					} else {
						//Trace(&quot;LOAD &quot;+line);

						line.split(&quot;;&quot;).each(function (n, arg) {
							// process one file at a time

							var tok = arg.replace(&quot;Content-Disposition: &quot;, &quot;disposition=&quot;).replace(&quot;Content-Type: &quot;, &quot;type=&quot;).split(&quot;=&quot;),
							    val = tok.pop(),
							    key = tok.pop();

							if (key) parms[key.replace(/ /g, &quot;&quot;)] = val.replace(/&quot;/g, &quot;&quot;);
						});
					}
				});

				//Log(files);
				return { files: files };
			}));else cb({});
		});
	}

	function startSession(cb) {
		//&lt; callback cb() if not combating denial of service attacks
<span id='TOTEM-Utilities-Thread_Processing-method-startSession'>		/**
</span>  @private
  @method startSession
  Start session and protect from denial of service attacks.
  @param {Function} callback() when completed
  */

		if (BUSY &amp;&amp; (busy = TOTEM.errors.tooBusy)) if (BUSY()) return Res.end(TOTEM.errors.pretty(busy));

		switch (Req.method) {
			case &quot;PUT&quot;:
			case &quot;GET&quot;:
			case &quot;POST&quot;:
			case &quot;DELETE&quot;:
				return cb();

			case &quot;OPTIONS&quot;:
				// client making cross-domain call - must respond with what are valid methods
				//Req.method = Req.headers[&quot;access-control-request-method&quot;];
				Res.writeHead(200, {
					&quot;access-control-allow-origin&quot;: &quot;*&quot;,
					&quot;access-control-allow-methods&quot;: &quot;POST, GET, DELETE, PUT, OPTIONS&quot;
				});
				Res.end();

				/*res.header = function () {
    	Res.writeHead(200);
    	Res.socket.write(Res._header);
    	Res.socket.write(Res._header);
    	Res._headerSent = true;
    }; */

				break;

			default:
				Res.end(TOTEM.errors.pretty(TOTEM.errors.badMethod));
		}
	}

	function conThread(req, res) {
<span id='TOTEM-Utilities-Thread_Processing-method-conThread'>		/**
</span>   @private
   @method conThread
   Start a session by attaching sql, cert, client, profile and session info to this request req with callback res(error).  
   @param {Object} req request
   @param {Function} res response
   * */
		var errors = TOTEM.errors,
		    paths = TOTEM.paths.mysql;

		if (sock = req.reqSocket) {
			if (TOTEM.mysql) // running with database so attach a sql connection 
				sqlThread(function (sql) {
					req.sql = sql;

					validateClient(req, function (err) {
						if (err) res(err);else if (getSession = paths.getSession) sql.query(getSession, { Client: req.client }, function (err, ses) {

							if (err) return res(err);

							req.session = new Object(ses[0] || {
								Client: &quot;guest@guest.org&quot;,
								Connects: 1,
								//ipAddress : &quot;unknown&quot;,
								Location: &quot;unknown&quot;,
								Joined: new Date()
							});

							res(null);
						});else {
							// using dummy sessions
							req.session = {};
							res(null);
						}
					});
				});else {
				// running w/o database so use dummy session
				req.session = {};
				res(null);
			}
		} else res(errors.lostConnection);
		//Res.end( TOTEM.errors.pretty(TOTEM.errors.lostConnection ) );
	}

	function getSocket() {
		// returns suitable response socket depending on cross/same domain session
		if (Req.headers.origin) {
			// cross domain session is in progress from master (on http) to its workers (on https)
			Res.writeHead(200, { &quot;content-type&quot;: &quot;text/plain&quot;, &quot;access-control-allow-origin&quot;: &quot;*&quot; });
			Res.socket.write(Res._header);
			Res._headerSent = true;
			return Res.socket;
		} else // same domain (http-to-http or https-to-https) so must use the request socket
			return Req.socket;
	}

	startSession(function () {
		// process if session not busy

		getBody(function (body) {
			// setup request with body parms 
			/* 
   Define request req 
   	.method = GET | PUT | POST | DELETE
   	.action = select | update | insert | delete
   	.reqSocket = socket to complete request
   	.resSocket = socket to complete response
   	socketio: path to client's socketio
   	body = hash of request key:value 
   	url = clean url
   */
			var paths = TOTEM.paths,
			    // parse request url into /area/nodes
			onEncrypted = TOTEM.onEncrypted[CLUSTER.isMaster],
			    // request being made to encrypted service
			req = Req.req = { // prime session request
				method: Req.method, // get,put, etc
				started: Req.headers.Date, // time client started request
				action: TOTEM.crud[Req.method],
				reqSocket: Req.socket, // use supplied request socket 
				resSocket: getSocket, // use this method to return a response socket
				encrypted: onEncrypted, // on encrypted worker
				socketio: onEncrypted ? TOTEM.site.urls.socketio : &quot;&quot;, // path to socket.io
				body: body, // body parameters
				url: Req.url == &quot;/&quot; ? paths.nourl : unescape(Req.url) // requested url
			},


			/*
   There exists an edge case wherein an html tag within json content, e.g a &lt;img src=&quot;/ABC&quot;&gt;
   embeded in a json string, is reflected back the server as a /%5c%22ABC%5c%22, which 
   unescapes to /\\&quot;ABC\\&quot;.  This is ok but can be confusing.
   */
			url = req.url,
			    // get a clean url

			nodes = TOTEM.nodeDivider // get a list of all nodes on the url
			? url ? url.split(TOTEM.nodeDivider) : [] : url ? [url] : [];

			conThread(req, function (err) {
				// start client connection and set the response header

				// must carefully set appropriate headers to prevent http-parse errors when using master-worker proxy
				if (onEncrypted) Res.setHeader(&quot;Set-Cookie&quot;, [&quot;client=&quot; + req.client, &quot;service=&quot; + TOTEM.host.name]);

				if (err) // connection rejected so we are done
					res(err);else if (nodes.length == 1) {
					// respond with only this node
					node = req.node = nodes.pop();
					routeNode(req, res);
				} else // respond with aggregate of all nodes
					routeNodes(nodes, {}, req, res);
			});
		});
	});
}

function proxyThread(req, res) {
	// not presently used but might want to support later

	var pathto = TOTEM.site.urls.master + req.path,

	//TOTEM.site.urls.master + &quot;/news&quot;,  
	//&quot;http://localhost:8081&quot; + req.path,

	proxy = URL.parse(pathto);

	proxy.method = req.method;

	Log(proxy, pathto);

	/*
 var sock = NET.connect( proxy.port );
 sock.setEncoding(&quot;utf8&quot;);
 sock.write(&quot;here is some data for u&quot;);
 sock.on(&quot;data&quot;, function (d) {
 	Log(&quot;sock rx&quot;, d);
 	res(d);
 }); */

	var Req = HTTP.request(pathto, function (Res) {
		Log(&quot;==========SETUP&quot;, Res.statusCode, Res.headers);

		var body = &quot;&quot;;

		Res.setEncoding(&quot;utf8&quot;);
		Res.on('data', function (chunk) {
			// will not trigger unless worker fails to end socket
			body += chunk;
		});

		Res.on(&quot;end&quot;, function () {
			Log(&quot;=========rx &quot; + body);
			res(body);
		});

		Res.on(&quot;error&quot;, function (err) {
			Log(&quot;what??? &quot; + err);
		});
	});

	Req.on('error', function (err) {
		Log(&quot;=========tx &quot; + err);
		res(&quot;oh well&quot;);
	});

	//Log( &quot;RELAY TX &quot;+JSON.stringify( req.body) );

	if (proxy.method == &quot;PUT&quot;) Req.write(JSON.stringify(req.body));

	Req.end();

	/*  
 generic
 		var http = require('http');
 
 http.createServer(function(request, response) {
   var proxy = http.createClient(80, request.headers['host'])
   var proxy_request = proxy.request(request.method, request.url, request.headers);
   proxy_request.addListener('response', function (proxy_response) {
     proxy_response.addListener('data', function(chunk) {
       response.write(chunk, 'binary');
     });
     proxy_response.addListener('end', function() {
       response.end();
     });
     response.writeHead(proxy_response.statusCode, proxy_response.headers);
   });
   request.addListener('data', function(chunk) {
     proxy_request.write(chunk, 'binary');
   });
   request.addListener('end', function() {
     proxy_request.end();
   });
 }).listen(8080);
 */

	/*
 var net = require('net');
 
 var LOCAL_PORT  = 6512;
 var REMOTE_PORT = 6512;
 var REMOTE_ADDR = &quot;192.168.1.25&quot;;
 
 var server = net.createServer(function (socket) {
     socket.on('data', function (msg) {
         Log('  ** START **');
         Log('&lt;&lt; From client to proxy ', msg.toString());
         var serviceSocket = new net.Socket();
         serviceSocket.connect(parseInt(REMOTE_PORT), REMOTE_ADDR, function () {
             Log('&gt;&gt; From proxy to remote', msg.toString());
             serviceSocket.write(msg);
         });
         serviceSocket.on(&quot;data&quot;, function (data) {
             Log('&lt;&lt; From remote to proxy', data.toString());
             socket.write(data);
             Log('&gt;&gt; From proxy to client', data.toString());
         });
     });
 });
 
 server.listen(LOCAL_PORT);
 Log(&quot;TCP server accepting connection on port: &quot; + LOCAL_PORT);
 */
}

function makeGuest(sql, client) {
	// return a suitable guest profile or null

	function userID(client) {
		// return suitable userID given a client name
		var parts = client.split(&quot;@&quot;),
		    parts = (parts[0] + &quot;.x.x&quot;).split(&quot;.&quot;),
		    userid = parts[2] == &quot;x&quot; ? parts[1].substr(0, 6) + parts[0].charAt(0) : parts[2].substr(0, 6) + parts[0].charAt(0) + parts[1].charAt(0);

		//Log(client,parts,userid);
		return userid;
	}

	var paths = TOTEM.paths.mysql;

	if (profile = TOTEM.guestProfile) {
		// allowing guests
		return Copy({
			Client: client,
			User: userID(client),
			Login: client,
			Requested: new Date()
		}, new Object(profile));

		sql.query(paths.newProfile, profile);
	} else return null;
}

/*
function simThread(sock) { 
	//Req.setSocketKeepAlive(true);
	Log({ip: sock.remoteAddress, port: sock.remotePort});
	sock.setEncoding(&quot;utf8&quot;);
	sock.on(&quot;data&quot;, function (req) {
		Log(&quot;sock data&gt;&gt;&gt;&gt;&quot;,req);
		var 
			Req = Copy({
				socket: sock  // used if master makes handoff
			}, JSON.parse(req)),
			
			Res = {  // used if master does not makes handoff
				end: function (ack) {
					sock.write(ack);
				}
			};
				
		sesThread(Req,Res);
	});
} */

<span id='TOTEM-End_Points-System'>/**
</span>@class TOTEM.End_Points.System
*/
function sysTask(req, res) {
	//&lt; task sharding
<span id='TOTEM-End_Points-System-method-sysTask'>	/**
</span> @method sysTask
 Totem (req,res)-endpoint to shard a task to totem compute nodes.
 @param {Object} req Totem request
 @param {Function} res Totem response
 */
	var query = req.query,
	    body = req.body,
	    sql = req.sql,
	    task = body.task,
	    dom = body.domain,
	    cb = body.cb,
	    $ = JSON.stringify({
		worker: CLUSTER.isWorker ? CLUSTER.worker.id : 0,
		node: process.env.HOSTNAME
	}),
	    engine = &quot;(&quot; + cb + &quot;)( (&quot; + task + &quot;)(&quot; + $ + &quot;) )&quot;,
	    plugins = TOTEM.plugins;

	res(&quot;ok&quot;);

	if (task &amp;&amp; cb) dom.forEach(function (index) {

		function runEngine(idx) {
			VM.runInContext(engine, VM.createContext(Copy(plugins, idx)));
		}

		if (body.qos) sql.insertJob({ // job descriptor 
			index: Copy(index, {}),
			priority: 0,
			qos: body.qos,
			class: req.table,
			client: body.client,
			credit: body.credit,
			name: body.name,
			task: body.name,
			notes: [req.table.tag(&quot;?&quot;, req.query).tag(&quot;a&quot;, { href: &quot;/&quot; + req.table + &quot;.run&quot; }), (body.credit &gt; 0 ? &quot;funded&quot; : &quot;unfunded&quot;).tag(&quot;a&quot;, { href: req.url }), &quot;RTP&quot;.tag(&quot;a&quot;, {
				href: &quot;/rtpsqd.view?task=&quot; + body.name
			}), &quot;PMR brief&quot;.tag(&quot;a&quot;, {
				href: &quot;/briefs.view?options=&quot; + body.name
			})].join(&quot; || &quot;)
		}, function (sql, job) {
			//Log(&quot;reg job&quot; , job);
			runEngine(job.index);
		});else runEngine(index);
	});
}

function sysPing(req, res) {
<span id='TOTEM-End_Points-System-method-sysPing'>	/**
</span> @method sysPing
 Totem (req,res)-endpoint to test client connection
 @param {Object} req Totem request
 @param {Function} res Totem response
 */
	res(&quot;hello &quot; + req.client);
}

function isEmpty(opts) {
	for (var key in opts) {
		return false;
	}return true;
}

function sysArea(req, res) {
<span id='TOTEM-End_Points-System-method-sysArea'>	/**
</span> @method sysArea
 Totem (req,res)-endpoint to send uncached, static files from a requested area.
 @param {Object} req Totem request
 @param {Function} res Totem response
 */

	var sql = req.sql,
	    query = req.query,
	    index = req.index,
	    body = req.body,
	    client = req.client,
	    action = req.action,
	    area = req.table,
	    path = req.path,
	    now = new Date();

	/*Log({
 	p: path,
 	q: query,
 	b: body,
 	a: area,
 	c: client,
 	n: req.file
 }); */

	switch (action) {
		case &quot;select&quot;:

			if (req.file) try {
				// these ifiles are not static so we dont cache them
				FS.readFile(path, &quot;utf8&quot;, function (err, buf) {

					if (err) res(err);else if (isEmpty(query)) res(buf);else {
						var src = buf.parseJSON({}),
						    rtn = {};

						Log(&quot;keys&quot;, query);
						Each(query, function (key, index) {
							return rtn[key] = index.parseEval(src);
						});

						res(JSON.stringify(rtn));
					}
				});
			} catch (err) {
				res(TOTEM.errors.noFile);
			} else indexFile(path, function (files) {
				// Send list of files under specified folder

				files.each(function (n, file) {
					files[n] = file.tag(&quot;a&quot;, { href: &quot;&quot; + file });
				});

				res(&quot;Index of &quot; + path + &quot;:&lt;br&gt;&quot; + files.join(&quot;&lt;br&gt;&quot;));
			});

			break;

		case &quot;delete&quot;:
			res(new Error(&quot;undefined&quot;));
			break;

		case &quot;update&quot;:
		case &quot;insert&quot;:
			var canvas = body.canvas || { objects: [] },
			    attach = [],
			    image = body.image,
			    files = image ? [{
				filename: client, //name, // + ( files.length ? &quot;_&quot;+files.length : &quot;&quot;), 
				size: image.length / 8,
				image: image
			}] : body.files || [],
			    tags = Copy(query.tag || {}, { Location: query.location || &quot;POINT(0 0)&quot; });

			res(&quot;uploading&quot;);

			canvas.objects.each(function (n, obj) {
				// upload provided canvas objects

				switch (obj.type) {
					case &quot;image&quot;:
						// ignore blob
						break;

					case &quot;rect&quot;:

						attach.push(obj);

						sql.query(&quot;REPLACE INTO proofs SET ?&quot;, {
							top: obj.top,
							left: obj.left,
							width: obj.width,
							height: obj.height,
							label: tag,
							made: now,
							name: area + &quot;.&quot; + name
						});
						break;
				}
			});

			files.forEach(function (file, n) {

				var buf = new Buffer(file.data, &quot;base64&quot;),
				    srcStream = new STREAM.Readable({ // source stream for event ingest
					objectMode: true,
					read: function read() {
						// return null if there are no more events
						this.push(buf);
						buf = null;
					}
				});

				Trace(&quot;UPLOAD &quot; + file.filename + &quot; INTO &quot; + area + &quot; FOR &quot; + client, sql);

				uploadFile(client, srcStream, &quot;./&quot; + area + &quot;/&quot; + file.filename, tags, function (fileID) {

					if (false) sql.query( // this might be generating an extra geo=null record for some reason.  works thereafter.
					&quot;INSERT INTO ??.files SET ?,Location=GeomFromText(?) &quot; + &quot;ON DUPLICATE KEY UPDATE Client=?,Added=now(),Revs=Revs+1,Location=GeomFromText(?)&quot;, [req.group, {
						Client: req.client,
						Name: file.filename,
						Area: area,
						Added: new Date(),
						Classif: query.classif || &quot;&quot;,
						Revs: 1,
						Ingest_Size: file.size,
						Ingest_Tag: query.tag || &quot;&quot;
					}, geoloc, req.client, geoloc]);

					if (false) sql.query( // credit the client
					&quot;UPDATE openv.profiles SET Credit=Credit+?,useDisk=useDisk+? WHERE ?&quot;, [1000, file.size, { Client: req.client }]);

					if (false) //(file.image)
						switch (area) {
							case &quot;proofs&quot;:

								sql.query(&quot;REPLACE INTO proofs SET ?&quot;, {
									top: 0,
									left: 0,
									width: file.Width,
									height: file.Height,
									label: tag,
									made: now,
									name: area + &quot;.&quot; + name
								});

								sql.query(&quot;SELECT detectors.ID, count(ID) AS counts FROM app.detectors LEFT JOIN proofs ON proofs.label LIKE detectors.PosCases AND proofs.name=? HAVING counts&quot;, [area + &quot;.&quot; + name]).on(&quot;result&quot;, function (det) {
									sql.query(&quot;UPDATE detectors SET Dirty=Dirty+1&quot;);
								});

								break;

						}
				});
			});
			break;

	}
}

[//&lt; date prototypes
].extend(Date);

[//&lt; Array prototypes
function parseJSON(ctx, def) {
	this.forEach(function (key) {
		try {
			ctx[key] = (ctx[key] || &quot;&quot;).parseJSON(function (val) {
				return def || null;
			});
		} catch (err) {
			//Log(err,key,rec[key]);
			ctx[key] = def || null;
		}
	});
	return ctx;
}].extend(Array);

[//&lt; String prototypes
function tag(el, at, eq) {
<span id='String-method-tag'>	/**
</span> @member String
 @method tag
 	Tag url (el=?) or tag html (el=html tag) with specified attributes.
 	@param {String} el tag element
 @param {String} at tag attributes
 @return {String} tagged results
 */

	if (el == &quot;?&quot; || el == &quot;&amp;&quot;) {
		// tag a url
		var rtn = this + el;

		for (var n in at) {
			var val = at[n];
			rtn += n + (eq || &quot;=&quot;) + (typeof val == &quot;string&quot; ? val : JSON.stringify(val)) + &quot;&amp;&quot;;
		}

		return rtn;
	} else {
		// tag html
		var rtn = &quot;&lt;&quot; + el + &quot; &quot;;

		for (var n in at) {
			var val = at[n];
			rtn += n + &quot;='&quot; + val + &quot;' &quot;;
		}

		switch (el) {
			case &quot;embed&quot;:
			case &quot;img&quot;:
			case &quot;link&quot;:
			case &quot;input&quot;:
				return rtn + &quot;&gt;&quot; + this;
			default:
				return rtn + &quot;&gt;&quot; + this + &quot;&lt;/&quot; + el + &quot;&gt;&quot;;
		}
	}
}, function parseEval($) {
<span id='String-method-parseEval'>	/**
</span> @member String
 @method parseEval
 	Parse &quot;$.KEY&quot; || &quot;$[INDEX]&quot; expressions given $ hash.
 	@param {Object} $ source hash
 */
	return eval(this + &quot;&quot;);
}, function parseJS(query) {
<span id='String-method-'>	/**
</span> @member String
 Return an EMAC &quot;...${...}...&quot; string using supplied req $-tokens and plugin methods.
 @param {Object} query context hash
 */
	try {
		return VM.runInContext(&quot;`&quot; + this + &quot;`&quot;, VM.createContext(query));
	} catch (err) {
		return err + &quot;&quot;;
	}
}, function parseJSON(def) {
<span id='String-method-parseJSON'>	/**
</span> @member String
 @method parseJSON
 Parse string into json.
 @param {Function,Object} def default object or callback that returns default
 */

	try {
		return JSON.parse(this);
	} catch (err) {
		return def ? (isFunction(def) ? def(this + &quot;&quot;) : def) || null : null;
	}
}, function parsePath(query, index, flags, where) {
<span id='String-method-parsePath'>	/**
</span> @member String
 @method parsePath
 
 Parse a &quot;PATH?PARM&amp;PARM&amp;...&quot; url into the specified query, index, flags, or keys hash
 as directed by the PARM = ASKEY := REL || REL || _FLAG = VALUE where 
 REL = X OP X || X, X = KEY || KEY$[IDX] || KEY$.KEY
 	@param {Object} query hash of query keys
 @param {Object} index hash of sql-ized indexing keys
 @param {Object} flags hash of flag keys
 @param {Object} where hash of sql-ized conditional keys
 */

	function doParm(str) {
		// expand parm str 
		doSample(str, function (res) {
			// not sampling so try relation
			doRelation(res, where, function (res) {
				// not relation so try index
				//Log(&quot;last guess&quot;, res);
				return index[res] = escapeId(res);
			});
		});
	}

	function doSample(str, cb) {
		// expand lhs := rhs or callback cb(str)
		function rep(lhs, op, rhs) {
			expand = true;
			var rel = doRelation(rhs, {}, function (res) {
				// not relation so assume id
				//Log(&quot;no test&quot;, res);
				return escapeId(res);
			});

			return rel + &quot; AS &quot; + escapeId(lhs);
		}

		var expand = false,
		    res = str.replace(/(.*)(:=)(.*)/, function (rem, lhs, op, rhs) {
			return index[lhs] = rep(lhs, op, rhs);
		});

		return expand ? res : cb(res);
	}

	function doStore(str, cb) {
		// expand &quot;store$expression, ...&quot; or callback(str)
		function rep(key, op, exp) {
			expand = true;
			var exs = exp.split(&quot;,&quot;);
			exs.forEach(function (ex, n) {
				return exs[n] = escape(op + ex);
			});
			return &quot;json_extract(&quot; + escapeId(key) + &quot;, &quot; + exs.join(&quot;,&quot;) + &quot; )&quot;;
		}

		var expand = false,
		    res = str.replace(/(.*)(\$)(.*)/, function (rem, lhs, op, rhs) {
			return rep(lhs, op, rhs);
		});

		return expand ? res : cb(str);
	}

	function doRelation(str, where, cb) {
		// expand &quot;where op val&quot; || &quot;_flag = json&quot; or callback(str)

		function rep(lhs, op, rhs) {
			//Log(&quot;dotest&quot;, lhs, op, rhs);
			expand = true;
			var key = doStore(lhs, function (res) {
				// lhs not a store so assume keys
				var keys = res.split(&quot;,&quot;);
				keys.forEach(function (key, n) {
					return keys[n] = escapeId(key);
				});
				return keys.join(&quot;,&quot;);
			}),
			    val = doStore(rhs, function (res) {
				return escape(res);
			});

			switch (op) {
				case &quot;/=&quot;:
					return &quot;MATCH(&quot; + key + &quot;) AGAINST(&quot; + val + &quot;)&quot;;
				case &quot;^=&quot;:
					return &quot;MATCH(&quot; + key + &quot;) AGAINST(&quot; + val + &quot; IN BINARY MODE)&quot;;
				case &quot;|=&quot;:
					return &quot;MATCH(&quot; + key + &quot;) AGAINST(&quot; + val + &quot; IN QUERY EXPANSION)&quot;;
				default:
					return key + &quot; &quot; + op + &quot; &quot; + val;
			}
		}

		var expand = false,
		    res = str.replace(/^_(.*)(=)(.*)/, function (rem, lhs, op, rhs) {
			// _flag=json
			expand = true;
			//Log(&quot;flags&quot;, lhs, rhs);
			flags[lhs] = rhs.parseJSON(function (res) {
				return res;
			});
			return rhs;
		});

		if (expand) return res;else {
			res = str.replace( // where op val
			/(.*)(\/=|\^=|\|=|&lt;=|&gt;=|\!=)(.*)/, function (rem, lhs, op, rhs) {
				return where[lhs] = rep(lhs, op, rhs);
			});

			if (expand) return res;else {
				res = str.replace( // query op val
				/(.*)(=|&lt;|&gt;)(.*)/, function (rem, lhs, op, rhs) {
					if (op == &quot;=&quot;) query[lhs] = rhs;
					return where[lhs] = rep(lhs, op, rhs);
				});

				return expand ? res : doStore(str, cb);
			}
		}
	}

	var escape = MYSQL.escape,
	    escapeId = MYSQL.escapeId,
	    parts = this.split(&quot;?&quot;);

	if (parms = parts[1]) parms.split(&quot;&amp;&quot;).forEach(function (parm) {
		if (parm) doParm(parm);
	});

	//delete query[&quot;&quot;];

	Log({ query: query, index: index, flags: flags, where: where, path: parts[0] });

	return parts[0];
}, function parseXML(cb) {
<span id='String-method-parseXML'>	/**
</span> @member String
 @method parseXML
 
 Parse XML string into json and callback cb(json) 
 	@param {Function} cb callback( json || null if error )
 */
	XML2JS.parseString(this, function (err, json) {
		cb(err ? null : json);
	});
}].extend(String);

//=================================== unit testing

<span id='TOTEM-Unit_Tests_Use_Cases'>/**
</span>@class TOTEM.Unit_Tests_Use_Cases
*/

switch (process.argv[2]) {//&lt; unit tests
	case &quot;?&quot;:
		Log(&quot;unit test with 'node totem.js [T1 || T2 || ...]'&quot;);
		break;

	case &quot;T1&quot;:
<span id='TOTEM-Unit_Tests_Use_Cases-method-T1'>		/**
</span>  @method T1
  Create simple service but dont start it.
  */
		var TOTEM = require(&quot;../totem&quot;);

		Trace({
			msg: &quot;Im simply a Totem interface so Im not even running as a service&quot;,
			default_fetcher_endpts: TOTEM.byTable,
			default_protect_mode: TOTEM.faultless,
			default_cores_used: TOTEM.cores
		});
		break;

	case &quot;T2&quot;:
<span id='TOTEM-Unit_Tests_Use_Cases-method-T2'>		/**
</span>  @method T2
  Totem service running in fault protection mode, no database, no UI; but I am running
  with 2 workers and the default endpoint routes.
  */
		var TOTEM = require(&quot;../totem&quot;).config({
			mysql: null,
			faultless: true,
			cores: 2
		}, function (err) {

			Trace(err || &quot;I'm a Totem service running in fault protection mode, no database, no UI; but I am running\nwith 2 workers and the default endpoint routes&quot;);
		});
		break;

	case &quot;T3&quot;:
<span id='TOTEM-Unit_Tests_Use_Cases-method-T3'>		/**
</span>  @method T3
  I'm a Totem service with no workers. I do, however, have a mysql database from which I've derived 
  my startup options (see the openv.apps table for the Nick=&quot;Totem1&quot;).  
  No endpoints to speak off (execept for the standard wget, riddle, etc) but you can hit &quot;/files/&quot; to index 
  these files. 
  */

		var TOTEM = require(&quot;../totem&quot;).config({}, function (err) {
			Trace(err || &quot;I'm a Totem service with no workers. I do, however, have a mysql database from which I've derived \nmy startup options (see the openv.apps table for the Nick=\&quot;Totem1\&quot;).  \nNo endpoints to speak off (execept for the standard wget, riddle, etc) but you can hit \&quot;/files/\&quot; to index \nthese files. &quot;);
		});
		break;

	case &quot;T4&quot;:
<span id='TOTEM-Unit_Tests_Use_Cases-method-T4'>		/**
</span>  @method T4
  As always, if the openv.apps Encrypt is set for the Nick=&quot;Totem&quot; app, this service is now **encrypted** [*]
  and has https (vs http) endpoints, here /dothis and /dothat endpoints.  Ive only requested only 1 worker (
  aka core), Im running unprotected, and have a mysql database.  
  [*] If my NICK.pfx does not already exists, Totem will create its password protected NICK.pfx cert from the
  associated public NICK.crt and private NICK.key certs it creates.
  */

		var TOTEM = require(&quot;../totem&quot;).config({
			byTable: {
				dothis: function dothis(req, res) {
					//&lt; named handlers are shown in trace in console
					res(&quot;123&quot;);

					Trace({
						do_query: req.query
					});
				},

				dothat: function dothat(req, res) {

					if (req.query.x) res([{ x: req.query.x + 1, y: req.query.x + 2 }]);else res(new Error(&quot;We have a problem huston&quot;));

					Trace({
						msg: &quot;Like dothis, but needs an ?x=value query&quot;,
						or_query: req.query,
						or_user: [req.client, req.group]
					});
				}
			}
		}, function (err) {
			Trace(err || {
				msg: &quot;As always, if the openv.apps Encrypt is set for the Nick=\&quot;Totem\&quot; app, this service is now **encrypted** [*]\nand has https (vs http) endpoints, here /dothis and /dothat endpoints.  Ive only requested only 1 worker (\naka core), Im running unprotected, and have a mysql database.  \n[*] If my NICK.pfx does not already exists, Totem will create its password protected NICK.pfx cert from the\nassociated public NICK.crt and private NICK.key certs it creates.&quot;,
				my_endpoints: TOTEM.byTable
			});
		});
		break;

	case &quot;T5&quot;:
<span id='TOTEM-Unit_Tests_Use_Cases-method-T5'>		/**
</span>  @method T5
  I am Totem client, with no cores but I do have mysql database and I have an anti-bot shield!!  Anti-bot
  shields require a Encrypted service, and a UI (like that provided by DEBE) to be of any use.
  */

		var TOTEM = require(&quot;../totem&quot;).config({
			riddles: 20
		}, function (err) {
			Trace(err || {
				msg: &quot;I am Totem client, with no cores but I do have mysql database and I have an anti-bot shield!!  Anti-bot\nshields require a Encrypted service, and a UI (like that provided by DEBE) to be of any use.&quot;,
				mysql_derived_parms: TOTEM.site
			});
		});
		break;

	case &quot;T6&quot;:
<span id='TOTEM-Unit_Tests_Use_Cases-method-T6'>		/**
</span>  @method T6
  Testing tasker with database and 3 cores at /test endpoint.
  */

		var TOTEM = require(&quot;../totem&quot;).config({
			faultless: false, // ex override default 
			cores: 3, // ex override default
			mysql: { // provide a database
				host: ENV.MYSQL_HOST,
				user: ENV.MYSQL_USER,
				pass: ENV.MYSQL_PASS
			},
			&quot;byTable.&quot;: { // define endpoints
				test: function test(req, res) {
					res(&quot; here we go&quot;); // endpoint must always repond to its client 
					if (CLUSTER.isMaster) // setup tasking examples on on master
						switch (req.query.opt || 1) {// test example tasker
							case 1:
								TOTEM.tasker({ // setup tasking for loops over these keys
									keys: &quot;i,j&quot;,
									i: [1, 2, 3],
									j: [4, 5]
								},
								// define the task which returns a message msg
								function ($) {
									return &quot;hello i,j=&quot; + [i, j] + &quot; from worker &quot; + $.worker + &quot; on &quot; + $.node;
								},

								// define the message msg handler
								function (msg) {
									return console.log(msg);
								});
								break;

							case 2:
								TOTEM.tasker({
									qos: 1,
									keys: &quot;i,j&quot;,
									i: [1, 2, 3],
									j: [4, 5]
								}, function ($) {
									return &quot;hello i,j=&quot; + [i, j] + &quot; from worker &quot; + $.worker + &quot; on &quot; + $.node;
								}, function (msg) {
									return console.log(msg);
								});
								break;

							case 3:
								break;
						}
				}
			}

		}, function (err) {
			Trace(err || &quot;Testing tasker with database and 3 cores at /test endpoint&quot;);
		});
		break;

	case &quot;T7&quot;:
<span id='TOTEM-Unit_Tests_Use_Cases-method-T7'>		/**
</span>  @method T7
  */

		var TOTEM = require(&quot;../totem&quot;).config({}, function (err) {
			Trace(err || &quot;db maintenance&quot;);

			if (CLUSTER.isMaster) TOTEM.thread(function (sql) {

				switch (process.argv[3]) {
					case 1:
						sql.query(&quot;select voxels.id as voxelID, chips.id as chipID from app.voxels left join app.chips on voxels.Ring = chips.Ring&quot;, function (err, recs) {
							Log(err);
							recs.each(function (n, rec) {
								sql.query(&quot;update app.voxels set chipID=? where ID=?&quot;, [rec.chipID, rec.voxelID], function (err) {
									Log(err);
								});
							});
						});
						break;

					case 2:
						sql.query(&quot;select ID, Ring from app.voxels&quot;, function (err, recs) {
							recs.each(function (n, rec) {
								sql.query(&quot;update app.voxels set Point=geomFromText(?) where ?&quot;, [&quot;POINT(&quot; + rec.Ring[0][0].x + &quot; &quot; + rec.Ring[0][0].y + &quot;)&quot;, { ID: rec.ID }], function (err) {
									Log(err);
								});
							});
						});
						break;

					case 3:
						sql.query(&quot;select voxels.id as voxelID, cache.id as chipID from app.voxels left join app.cache on voxels.Ring = cache.geo1&quot;, function (err, recs) {
							Log(err);
							recs.each(function (n, rec) {
								sql.query(&quot;update app.voxels set chipID=? where ID=?&quot;, [rec.chipID, rec.voxelID], function (err) {
									Log(err);
								});
							});
						});
						break;

					case 4:
						sql.query(&quot;select ID, geo1 from app.cache where bank='chip'&quot;, function (err, recs) {
							recs.each(function (n, rec) {
								if (rec.geo1) sql.query(&quot;update app.cache set x1=?, x2=? where ?&quot;, [rec.geo1[0][0].x, rec.geo1[0][0].y, { ID: rec.ID }], function (err) {
									Log(err);
								});
							});
						});
						break;

					case 5:
						var parms = {
							ring: &quot;[degs] closed ring [lon, lon], ... ]  specifying an area of interest on the earth's surface&quot;,
							&quot;chip length&quot;: &quot;[m] length of chip across an edge&quot;,
							&quot;chip samples&quot;: &quot;[pixels] number of pixels across edge of chip&quot;
						};
					//get all tables and revise field comments with info data here -  archive parms - /parms in flex will
					//use getfileds to get comments and return into

					case 6:
						var RAN = require(&quot;../randpr&quot;),
						    ran = new RAN({
							models: [&quot;sinc&quot;],
							Mmax: 150, // max coherence intervals
							Mstep: 5 // step intervals
						});

						ran.config(function (pc) {
							var vals = pc.values,
							    vecs = pc.vectors,
							    N = vals.length,
							    ref = vals[N - 1];

							vals.forEach(function (val, idx) {
								var save = {
									correlation_model: pc.model,
									coherence_intervals: pc.intervals,
									eigen_value: val,
									eigen_index: idx,
									ref_value: ref,
									max_intervals: ran.Mmax,
									eigen_vector: JSON.stringify(vecs[idx])
								};

								sql.query(&quot;INSERT INTO app.pcs SET ? ON DUPLICATE KEY UPDATE ?&quot;, [save, save]);
							});
						});
						break;
				}
			});
		});
		break;
}

// UNCLASSIFIED</pre>
</body>
</html>
